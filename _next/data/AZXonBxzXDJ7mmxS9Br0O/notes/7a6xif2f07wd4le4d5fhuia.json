{"pageProps":{"note":{"id":"7a6xif2f07wd4le4d5fhuia","title":"Solving problems","desc":"","updated":1711377169037,"created":1664638436236,"custom":{},"fname":"interviews.Solving problems","type":"note","vault":{"fsPath":"vault"},"contentHash":"657c15195ae3ee49eaeacaee88375526","links":[],"anchors":{"algorithms":{"type":"header","text":"Algorithms","value":"algorithms","line":8,"column":0,"depth":1},"strategies":{"type":"header","text":"Strategies:","value":"strategies","line":34,"column":0,"depth":1},"topics":{"type":"header","text":"Topics","value":"topics","line":42,"column":0,"depth":1},"knowledge":{"type":"header","text":"Knowledge","value":"knowledge","line":58,"column":0,"depth":1},"probability-brain-teasers":{"type":"header","text":"Probability, Brain teasers","value":"probability-brain-teasers","line":99,"column":0,"depth":1}},"children":[],"parent":"9r5ym61dkwap92fvbte1jkq","data":{}},"body":"<h1 id=\"solving-problems\">Solving problems<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#solving-problems\"></a></h1>\n<h1 id=\"algorithms\">Algorithms<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#algorithms\"></a></h1>\n<p><strong>Steps</strong></p>\n<ol>\n<li>Ask questions:\n1.1 about input (size, values, all constraints, sorted, duplicates)\n1.2 find solution -> chekcif there is input data for which the solution does not exist</li>\n<li>Play around with a examples (Visualize problem)\n2.1 Think edge cases (especially linked lists)\nTTD Write tests before writing code!!!</li>\n<li>Get brute force solution</li>\n<li>Write all steps of the algorithm before actually writing it.\n4.1 Write interface functions first each, then implement!\n4.2 Power of abstraction, encapsulate your code by naming\ndifferent  logics - get your spell!</li>\n<li>Test code in you head out loud without running it</li>\n</ol>\n<p>When you are asked about another solution to the problem:</p>\n<ul>\n<li>recursion vs iteration</li>\n<li>mention call stack, python is 10000 </li>\n<li>recursion smart way to procastinate work to be done later</li>\n<li>recursion cannot control memory</li>\n<li>can do tail recursion in compiled languages (C, C++, Lisp) reduce memory from O(n) -> O(1)</li>\n<li>Online vs Offline (Given input upfront vs Data Stream) often for Online you'd use Balanced Binary Search Tree</li>\n</ul>\n<h1 id=\"strategies\">Strategies:<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#strategies\"></a></h1>\n<ul>\n<li>directly writing code is BAD, think conceptually first- not like you do leetcodede!!!!</li>\n<li>strategy of wishful thinking- when using Data Structures that are not implemented yet just image you have them, solve the problem and only after that design them</li>\n<li>linked list questions modularize functions!! <a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/submissions/\">see power</a></li>\n<li>linked list often use two pointers</li>\n<li>finding good examples and playing around them</li>\n<li>for monotonic stack problems better go through example and write steps before that</li>\n</ul>\n<h1 id=\"topics\">Topics<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#topics\"></a></h1>\n<ul>\n<li>BST delete procedure picture of cases from Intro to algo book page 297, dbabichev recursive!</li>\n<li>power of 2 table 1KB,1MB..</li>\n<li>latency table in System Design book An insider guide</li>\n<li>BIT visualization</li>\n<li>Manachers Algorithm + example to go through + exaplnation of O(n)</li>\n<li>Morris Traversal of a tree O(1) memory! no stack or recursion</li>\n<li>Popular questions like Median of two sorted lists, REgular expression matching\nsee in leetcode popular questions for the company you are interviewing</li>\n<li>Palindrome question patterns: around center check, Manacher, DP (dp(i,j) usually), rolling hash</li>\n<li>Stream processing (one way to have conventional interface)\n[enumerate] ---- [map] ------ [filter] ------- [accumulate]\nrange(n)<br>\nstream creation------ map(fib,stream)------ filter(isodd,stream)-------sum(stream), tuple(stream)</li>\n<li>Trie Implementation</li>\n</ul>\n<h1 id=\"knowledge\">Knowledge<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#knowledge\"></a></h1>\n<ul>\n<li>OOP > Function programming,  Message passing and dispatch is much neater?\noriented programming whose idea of message passing scales better?</li>\n<li>Functional programming > OOP as it is mathematical. No assingment in Functional\nand this does not break mathematics. In OOP we use environmenta model of\ncomputation to understand the process of program execution. Can be messy.</li>\n<li>DP two key ingredients: Optimal substructure + Overlapping subproblems.</li>\n</ul>\n<ol>\n<li>Determine subproblem space + choice -> See if there is Optimal substructure\nie if an optimal solution to the problem contains within it optimal solutions t subproblems.\n<ul>\n<li>To characterize the space of subproblems, a good rule of thumb says to try to\nkeep the space as simple as possible and then expand it as necessary.</li>\n</ul>\n</li>\n<li>Recursive equation</li>\n<li>Reconstruct solution by keeping extra decision table in point 2</li>\n</ol>\n<ul>\n<li>Top- down(Memo) vs Bottom up:\nif all subproblems must be solved at least once, a bottom-up\ndynamic-programming algorithm usually outperforms the corresponding top-down\nmemoized algorithm by a constant factor, because the bottom-up algorithm has no\noverhead for recursion and less overhead for maintaining the table. Moreover, for\nsome problems we can exploit the regular pattern of table accesses in the dynamic-\nprogramming algorithm to reduce time or space requirements even further. Alter-\nnatively, if some subproblems in the subproblem space need not be solved at all,\nthe memoized solution has the advantage of solving only those subproblems that\nare deÔ¨Ånitely required.</li>\n<li>Greedy. How can we tell whether a greedy algorithm will solve a particular\noptimization problem? No way works all the time, but the greedy-choice property\nand optimal substructure are the two key ingredients.</li>\n</ul>\n<ol start=\"4\">\n<li>Dnamyc bindings in python environmental model\n4.1 def modify(ls,m):\nls[0]= 1\nm += 1\nls= [222,3]\nm = 0 # m not changed\nls = [3,2,1] # changes ls[0] to 1 but does not assign ls, argument  passed by value\nwhere the value is a copy of the reference. Similar thing in Java!\nobjects are passed by copy of reference, primitive types ae copy of themselves\nmodify(ls,m)</li>\n<li>Binary Search problems often can be solved with Two pointers! They have the same underlying idea of restring the search space in a consistent way</li>\n<li>Loop invariant proofs of correctness</li>\n<li>Before using Tries - consider using rolling hash of the string</li>\n</ol>\n<h1 id=\"probability-brain-teasers\">Probability, Brain teasers<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#probability-brain-teasers\"></a></h1>\n<ul>\n<li>Start with extreme numbers (either very small or very large).</li>\n<li>Symmetry</li>\n<li>Bayesian theorem</li>\n<li>ask as many questions as you need, especially during technical interviews</li>\n<li>break down approach into small manageable steps</li>\n<li></li>\n</ul>","noteIndex":{"id":"wn8PE1RhG0znK1alrGFYv","title":"Root","desc":"","updated":1763992060664,"created":1631901573363,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"dc095b340c158394d643b84f8585ff0c","links":[],"anchors":{},"children":["dgcsvcwea8scgdegrk9tfni","xig93vo47ou1bkr7s4w1wb2","ro9bbyftsutm88mxw6r16p5","ypia1zmywsklpicmcgrzlz1","w7iitlako61ppm27mym400a","6bx5plramu4hksomqc1n55z","4nki3bedlvs3mnkixj3a07k","9r5ym61dkwap92fvbte1jkq","849u97nrsuyekmr4a1r92ux","2b5bwf46z6v132wu7xghvrp","dygp5h2vzw4mkromwmofynb","7h50s7ga5ziiyblmoctsqmw","pglaolxcge4xfvgoph3je89","uy9u1co5ih1fokind8tg0eq","jc23ggp8iiu92kpnzo721to","f1u2a47guuw70olv36bzf66","c1bs7wsjfbhb0zipaywqv1","2av385tcj2cbumxprsauff3","lw1b4r6ykimvj9208nkgzps"],"parent":null,"data":{},"body":"\nZdr bebce kp ;)\n\nThis is my knowledge base, additionally I keep [daily journal](https://docs.google.com/document/d/1m8Npu0-t8RweyKiHCjLL1PPDYzbebqm3OZDHH8IVsb8/edit?tab=t.rj0kvkrm7zpr)."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableUserTags":true,"enableHashTags":true,"dendronVersion":"0.95.0","enableEditorDecorations":true,"enableFullHierarchyNoteTitle":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","assetsPrefix":"/dendron-wiki","siteUrl":"https://ngocuong0105.github.io","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"theme":"light","templateVersion":"0.97.0","ga":{"tracking":"G-W5DRRLQ1N7"},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}