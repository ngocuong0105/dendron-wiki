\BOOKMARK [1][-]{section.1}{Introduction}{}% 1
\BOOKMARK [1][-]{section.2}{Lecture 1A: Overview and introduction to Lisp}{}% 2
\BOOKMARK [2][-]{subsection.2.1}{What is Computer Science?}{section.2}% 3
\BOOKMARK [2][-]{subsection.2.2}{Techniques in CS to control complexity}{section.2}% 4
\BOOKMARK [2][-]{subsection.2.3}{General framework for thinking about languages}{section.2}% 5
\BOOKMARK [2][-]{subsection.2.4}{The elements of programming}{section.2}% 6
\BOOKMARK [2][-]{subsection.2.5}{Procedures as black-box abstractions}{section.2}% 7
\BOOKMARK [2][-]{subsection.2.6}{Summary}{section.2}% 8
\BOOKMARK [1][-]{section.3}{Lecture 1B: Procedures and Processes; Substitution Model}{}% 9
\BOOKMARK [2][-]{subsection.3.1}{How does computer execute code?}{section.3}% 10
\BOOKMARK [2][-]{subsection.3.2}{Procedures and the Processes they generate. iterative vs Recursive processes}{section.3}% 11
\BOOKMARK [2][-]{subsection.3.3}{Order of growth}{section.3}% 12
\BOOKMARK [2][-]{subsection.3.4}{Greatest common divisor}{section.3}% 13
\BOOKMARK [2][-]{subsection.3.5}{Example: Testing for Primalily}{section.3}% 14
\BOOKMARK [1][-]{section.4}{Lecture 2A: Higher-order Procedures}{}% 15
\BOOKMARK [1][-]{section.5}{Lecture Lecture 2B: Compound Data}{}% 16
\BOOKMARK [2][-]{subsection.5.1}{Building Abstractions with Data}{section.5}% 17
\BOOKMARK [3][-]{subsubsection.5.1.1}{Abstraction Barriers}{subsection.5.1}% 18
\BOOKMARK [2][-]{subsection.5.2}{What is Meant by Data?}{section.5}% 19
\BOOKMARK [1][-]{section.6}{Lecture 3A: Henderson Escher Example}{}% 20
\BOOKMARK [2][-]{subsection.6.1}{Hierarchical Data and the Closure Property}{section.6}% 21
\BOOKMARK [2][-]{subsection.6.2}{Representing Sequences in Lisp}{section.6}% 22
\BOOKMARK [2][-]{subsection.6.3}{Example: A Picture Language}{section.6}% 23
\BOOKMARK [2][-]{subsection.6.4}{Stratified Design over Layered Design}{section.6}% 24
\BOOKMARK [1][-]{section.7}{Lecture 3B: Symbolic Differentiation. Quotation}{}% 25
\BOOKMARK [2][-]{subsection.7.1}{Example: Symbolic Differentiation}{section.7}% 26
\BOOKMARK [2][-]{subsection.7.2}{Example: Representing Sets}{section.7}% 27
\BOOKMARK [2][-]{subsection.7.3}{Sets as unordered lists}{section.7}% 28
\BOOKMARK [2][-]{subsection.7.4}{Sets as ordered lists}{section.7}% 29
\BOOKMARK [2][-]{subsection.7.5}{Sets as binary search trees}{section.7}% 30
\BOOKMARK [1][-]{section.8}{Lecture 4A: Pattern Matching and Rule-based Substitution}{}% 31
\BOOKMARK [1][-]{section.9}{Lecture 4B: Generic Operators}{}% 32
\BOOKMARK [2][-]{subsection.9.1}{Multiple Representations for Abstract Data}{section.9}% 33
\BOOKMARK [2][-]{subsection.9.2}{Representation for Complex Numbers}{section.9}% 34
\BOOKMARK [2][-]{subsection.9.3}{Tagged data}{section.9}% 35
\BOOKMARK [2][-]{subsection.9.4}{Data-Directed Programming and Additivity}{section.9}% 36
\BOOKMARK [2][-]{subsection.9.5}{Systems with Generic Operations}{section.9}% 37
\BOOKMARK [2][-]{subsection.9.6}{Big Summary}{section.9}% 38
\BOOKMARK [1][-]{section.10}{Lecture 5A: Assignment, State, and Environmental model.}{}% 39
\BOOKMARK [2][-]{subsection.10.1}{Assignment kills the substitution model}{section.10}% 40
\BOOKMARK [2][-]{subsection.10.2}{The Environment Model of Evaluation}{section.10}% 41
\BOOKMARK [2][-]{subsection.10.3}{The benefits and disadvantages of Assignment}{section.10}% 42
\BOOKMARK [2][-]{subsection.10.4}{Summary}{section.10}% 43
\BOOKMARK [1][-]{section.11}{Lecture 5B: Computational Objects. OOP vs Functional}{}% 44
\BOOKMARK [2][-]{subsection.11.1}{OOP vs Functional}{section.11}% 45
\BOOKMARK [1][-]{section.12}{Lecture 6A: Streams, Part 1}{}% 46
\BOOKMARK [2][-]{subsection.12.1}{Efficient Stream Programs}{section.12}% 47
\BOOKMARK [2][-]{subsection.12.2}{N Queens problem}{section.12}% 48
\BOOKMARK [2][-]{subsection.12.3}{Lecture 6B: Streams, Part 2}{section.12}% 49
\BOOKMARK [2][-]{subsection.12.4}{Infinite Streams}{section.12}% 50
\BOOKMARK [2][-]{subsection.12.5}{Normal order evaluation bs applicative order of evaluation}{section.12}% 51
\BOOKMARK [1][-]{section.13}{Lecture 7A: Metacircular Evaluator}{}% 52
\BOOKMARK [1][-]{section.14}{Lecture 7B: Metacircular Evaluator, Part 2}{}% 53
\BOOKMARK [2][-]{subsection.14.1}{Dynamic Binding of Variables}{section.14}% 54
\BOOKMARK [2][-]{subsection.14.2}{Delay evaluation of arguments in Applicative order of evaluation}{section.14}% 55
\BOOKMARK [1][-]{section.15}{Lecture 8A: Logic Programming, Part 1}{}% 56
\BOOKMARK [1][-]{section.16}{Lecture 8B: Logic Programming, Part 2}{}% 57
\BOOKMARK [2][-]{subsection.16.1}{Query Language Implementation}{section.16}% 58
\BOOKMARK [2][-]{subsection.16.2}{Primitive type}{section.16}% 59
\BOOKMARK [2][-]{subsection.16.3}{Means of combination}{section.16}% 60
\BOOKMARK [2][-]{subsection.16.4}{Means of abstraction - Rules}{section.16}% 61
\BOOKMARK [2][-]{subsection.16.5}{Evaluation}{section.16}% 62
\BOOKMARK [2][-]{subsection.16.6}{Is Logic Programming Mathematical Logic?}{section.16}% 63
\BOOKMARK [1][-]{section.17}{Lecture 9A: Register Machines}{}% 64
\BOOKMARK [2][-]{subsection.17.1}{Demystification of the Mechanisms of Execution}{section.17}% 65
\BOOKMARK [2][-]{subsection.17.2}{Build machine language for recursive processes}{section.17}% 66
\BOOKMARK [1][-]{section.18}{Lecture 9B: Explicit-control Evaluator}{}% 67
\BOOKMARK [2][-]{subsection.18.1}{Evaluator \(Partial\)}{section.18}% 68
\BOOKMARK [2][-]{subsection.18.2}{Applicator}{section.18}% 69
\BOOKMARK [1][-]{section.19}{Lecture 10A: Compilation}{}% 70
\BOOKMARK [2][-]{subsection.19.1}{Interpreters}{section.19}% 71
\BOOKMARK [2][-]{subsection.19.2}{Compilers}{section.19}% 72
\BOOKMARK [2][-]{subsection.19.3}{Optimizations}{section.19}% 73
\BOOKMARK [2][-]{subsection.19.4}{Compiler general strategy}{section.19}% 74
\BOOKMARK [1][-]{section.20}{Lecture 10B: Storage Allocation and Garbage Collection}{}% 75
\BOOKMARK [2][-]{subsection.20.1}{Data Structure Representation}{section.20}% 76
\BOOKMARK [2][-]{subsection.20.2}{Allocation}{section.20}% 77
\BOOKMARK [2][-]{subsection.20.3}{Garbage Collection}{section.20}% 78
\BOOKMARK [3][-]{subsubsection.20.3.1}{Mark and Sweep Strategy}{subsection.20.3}% 79
\BOOKMARK [3][-]{subsubsection.20.3.2}{Minsky-Fenichel-Yochelson Algorithm}{subsection.20.3}% 80
\BOOKMARK [2][-]{subsection.20.4}{Not Everything Can Be Computed - Halting Theorem}{section.20}% 81
\BOOKMARK [2][-]{subsection.20.5}{Proof by contradiction}{section.20}% 82
