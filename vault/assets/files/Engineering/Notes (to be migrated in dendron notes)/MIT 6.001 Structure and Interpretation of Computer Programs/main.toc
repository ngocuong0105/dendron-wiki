\contentsline {section}{\numberline {1}Introduction}{1}{section.1}%
\contentsline {section}{\numberline {2}Lecture 1A: Overview and introduction to Lisp}{1}{section.2}%
\contentsline {subsection}{\numberline {2.1}What is Computer Science?}{1}{subsection.2.1}%
\contentsline {subsection}{\numberline {2.2}Techniques in CS to control complexity}{2}{subsection.2.2}%
\contentsline {subsection}{\numberline {2.3}General framework for thinking about languages}{2}{subsection.2.3}%
\contentsline {subsection}{\numberline {2.4}The elements of programming}{3}{subsection.2.4}%
\contentsline {subsection}{\numberline {2.5}Procedures as black-box abstractions}{4}{subsection.2.5}%
\contentsline {subsection}{\numberline {2.6}Summary}{5}{subsection.2.6}%
\contentsline {section}{\numberline {3}Lecture 1B: Procedures and Processes; Substitution Model}{6}{section.3}%
\contentsline {subsection}{\numberline {3.1}How does computer execute code?}{6}{subsection.3.1}%
\contentsline {subsection}{\numberline {3.2}Procedures and the Processes they generate. iterative vs Recursive processes}{7}{subsection.3.2}%
\contentsline {subsection}{\numberline {3.3}Order of growth}{7}{subsection.3.3}%
\contentsline {subsection}{\numberline {3.4}Greatest common divisor}{8}{subsection.3.4}%
\contentsline {subsection}{\numberline {3.5}Example: Testing for Primalily}{8}{subsection.3.5}%
\contentsline {section}{\numberline {4}Lecture 2A: Higher-order Procedures}{8}{section.4}%
\contentsline {section}{\numberline {5}Lecture Lecture 2B: Compound Data}{10}{section.5}%
\contentsline {subsection}{\numberline {5.1}Building Abstractions with Data}{10}{subsection.5.1}%
\contentsline {subsubsection}{\numberline {5.1.1}Abstraction Barriers}{11}{subsubsection.5.1.1}%
\contentsline {subsection}{\numberline {5.2}What is Meant by Data?}{11}{subsection.5.2}%
\contentsline {section}{\numberline {6}Lecture 3A: Henderson Escher Example}{13}{section.6}%
\contentsline {subsection}{\numberline {6.1}Hierarchical Data and the Closure Property}{13}{subsection.6.1}%
\contentsline {subsection}{\numberline {6.2}Representing Sequences in Lisp}{13}{subsection.6.2}%
\contentsline {subsection}{\numberline {6.3}Example: A Picture Language}{14}{subsection.6.3}%
\contentsline {subsection}{\numberline {6.4}Stratified Design over Layered Design}{17}{subsection.6.4}%
\contentsline {section}{\numberline {7}Lecture 3B: Symbolic Differentiation. Quotation}{21}{section.7}%
\contentsline {subsection}{\numberline {7.1}Example: Symbolic Differentiation}{22}{subsection.7.1}%
\contentsline {subsection}{\numberline {7.2}Example: Representing Sets}{24}{subsection.7.2}%
\contentsline {subsection}{\numberline {7.3}Sets as unordered lists}{24}{subsection.7.3}%
\contentsline {subsection}{\numberline {7.4}Sets as ordered lists}{24}{subsection.7.4}%
\contentsline {subsection}{\numberline {7.5}Sets as binary search trees}{24}{subsection.7.5}%
\contentsline {section}{\numberline {8}Lecture 4A: Pattern Matching and Rule-based Substitution}{25}{section.8}%
\contentsline {section}{\numberline {9}Lecture 4B: Generic Operators}{25}{section.9}%
\contentsline {subsection}{\numberline {9.1}Multiple Representations for Abstract Data}{25}{subsection.9.1}%
\contentsline {subsection}{\numberline {9.2}Representation for Complex Numbers}{26}{subsection.9.2}%
\contentsline {subsection}{\numberline {9.3}Tagged data}{28}{subsection.9.3}%
\contentsline {subsection}{\numberline {9.4}Data-Directed Programming and Additivity}{28}{subsection.9.4}%
\contentsline {subsection}{\numberline {9.5}Systems with Generic Operations}{29}{subsection.9.5}%
\contentsline {subsection}{\numberline {9.6}Big Summary}{30}{subsection.9.6}%
\contentsline {section}{\numberline {10}Lecture 5A: Assignment, State, and Environmental model.}{31}{section.10}%
\contentsline {subsection}{\numberline {10.1}Assignment kills the substitution model}{31}{subsection.10.1}%
\contentsline {subsection}{\numberline {10.2}The Environment Model of Evaluation}{32}{subsection.10.2}%
\contentsline {subsection}{\numberline {10.3}The benefits and disadvantages of Assignment}{32}{subsection.10.3}%
\contentsline {subsection}{\numberline {10.4}Summary}{33}{subsection.10.4}%
\contentsline {section}{\numberline {11}Lecture 5B: Computational Objects. OOP vs Functional}{33}{section.11}%
\contentsline {subsection}{\numberline {11.1}OOP vs Functional}{34}{subsection.11.1}%
\contentsline {section}{\numberline {12}Lecture 6A: Streams, Part 1}{34}{section.12}%
\contentsline {subsection}{\numberline {12.1}Efficient Stream Programs}{35}{subsection.12.1}%
\contentsline {subsection}{\numberline {12.2}N Queens problem}{36}{subsection.12.2}%
\contentsline {subsection}{\numberline {12.3}Lecture 6B: Streams, Part 2}{36}{subsection.12.3}%
\contentsline {subsection}{\numberline {12.4}Infinite Streams}{37}{subsection.12.4}%
\contentsline {subsection}{\numberline {12.5}Normal order evaluation bs applicative order of evaluation}{37}{subsection.12.5}%
\contentsline {section}{\numberline {13}Lecture 7A: Metacircular Evaluator}{38}{section.13}%
\contentsline {section}{\numberline {14}Lecture 7B: Metacircular Evaluator, Part 2}{40}{section.14}%
\contentsline {subsection}{\numberline {14.1}Dynamic Binding of Variables}{40}{subsection.14.1}%
\contentsline {subsection}{\numberline {14.2}Delay evaluation of arguments in Applicative order of evaluation}{41}{subsection.14.2}%
\contentsline {section}{\numberline {15}Lecture 8A: Logic Programming, Part 1}{41}{section.15}%
\contentsline {section}{\numberline {16}Lecture 8B: Logic Programming, Part 2}{42}{section.16}%
\contentsline {subsection}{\numberline {16.1}Query Language Implementation}{43}{subsection.16.1}%
\contentsline {subsection}{\numberline {16.2}Primitive type}{43}{subsection.16.2}%
\contentsline {subsection}{\numberline {16.3}Means of combination}{43}{subsection.16.3}%
\contentsline {subsection}{\numberline {16.4}Means of abstraction - Rules}{45}{subsection.16.4}%
\contentsline {subsection}{\numberline {16.5}Evaluation}{45}{subsection.16.5}%
\contentsline {subsection}{\numberline {16.6}Is Logic Programming Mathematical Logic?}{45}{subsection.16.6}%
\contentsline {section}{\numberline {17}Lecture 9A: Register Machines}{45}{section.17}%
\contentsline {subsection}{\numberline {17.1}Demystification of the Mechanisms of Execution}{45}{subsection.17.1}%
\contentsline {subsection}{\numberline {17.2}Build machine language for recursive processes}{47}{subsection.17.2}%
\contentsline {section}{\numberline {18}Lecture 9B: Explicit-control Evaluator}{48}{section.18}%
\contentsline {subsection}{\numberline {18.1}Evaluator (Partial)}{50}{subsection.18.1}%
\contentsline {subsection}{\numberline {18.2}Applicator}{51}{subsection.18.2}%
\contentsline {section}{\numberline {19}Lecture 10A: Compilation}{52}{section.19}%
\contentsline {subsection}{\numberline {19.1}Interpreters}{52}{subsection.19.1}%
\contentsline {subsection}{\numberline {19.2}Compilers}{53}{subsection.19.2}%
\contentsline {subsection}{\numberline {19.3}Optimizations}{55}{subsection.19.3}%
\contentsline {subsection}{\numberline {19.4}Compiler general strategy}{55}{subsection.19.4}%
\contentsline {section}{\numberline {20}Lecture 10B: Storage Allocation and Garbage Collection}{56}{section.20}%
\contentsline {subsection}{\numberline {20.1}Data Structure Representation}{56}{subsection.20.1}%
\contentsline {subsection}{\numberline {20.2}Allocation}{58}{subsection.20.2}%
\contentsline {subsection}{\numberline {20.3}Garbage Collection}{58}{subsection.20.3}%
\contentsline {subsubsection}{\numberline {20.3.1}Mark and Sweep Strategy}{58}{subsubsection.20.3.1}%
\contentsline {subsubsection}{\numberline {20.3.2}Minsky-Fenichel-Yochelson Algorithm}{59}{subsubsection.20.3.2}%
\contentsline {subsection}{\numberline {20.4}Not Everything Can Be Computed - Halting Theorem}{60}{subsection.20.4}%
\contentsline {subsection}{\numberline {20.5}Proof by contradiction}{60}{subsection.20.5}%
