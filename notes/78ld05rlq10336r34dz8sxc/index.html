<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/dendron-wiki/favicon.ico"/><title>Git</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Git"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://ngocuong0105.github.io/dendron-wiki/notes/78ld05rlq10336r34dz8sxc/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="11/12/2022"/><meta property="article:modified_time" content="4/14/2025"/><link rel="canonical" href="https://ngocuong0105.github.io/dendron-wiki/notes/78ld05rlq10336r34dz8sxc/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/dendron-wiki/_next/static/css/73bff7fc08ed1d26.css" as="style"/><link rel="stylesheet" href="/dendron-wiki/_next/static/css/73bff7fc08ed1d26.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/dendron-wiki/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/dendron-wiki/_next/static/chunks/webpack-5a49f804ab2869ab.js" defer=""></script><script src="/dendron-wiki/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/dendron-wiki/_next/static/chunks/main-2a75a40d33729b12.js" defer=""></script><script src="/dendron-wiki/_next/static/chunks/pages/_app-47f94d7e2ed9c5e2.js" defer=""></script><script src="/dendron-wiki/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/dendron-wiki/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/dendron-wiki/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/dendron-wiki/_next/static/AZXonBxzXDJ7mmxS9Br0O/_buildManifest.js" defer=""></script><script src="/dendron-wiki/_next/static/AZXonBxzXDJ7mmxS9Br0O/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="git">Git<a aria-hidden="true" class="anchor-heading icon-link" href="#git"></a></h1>
<h1 id="resources">Resources:<a aria-hidden="true" class="anchor-heading icon-link" href="#resources"></a></h1>
<ul>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a>.</li>
<li><a href="https://git.github.io/git-reference/creating/#init">Git reference common commands</a></li>
</ul>
<h1 id="commits-and-branches">Commits and branches<a aria-hidden="true" class="anchor-heading icon-link" href="#commits-and-branches"></a></h1>
<p>A <strong>commit</strong> in a git repository records a snapshot of all the (tracked) files in your directory. It's like a giant copy and paste, but even better!</p>
<p><strong>commit = snapshot of the project = lightweight safe of project state</strong> </p>
<p>Commits can be visually represented as nodes.</p>
<ul>
<li>create a commit</li>
</ul>
<pre class="language-s"><code class="language-s">git commit -m 'commit message'
</code></pre>
<p><strong>Branches = pointer to a specific commit</strong></p>
<p><em>'branch early, and branch often'</em></p>
<p>Branches are super lightweight and have no storage/memory overhead</p>
<p>Branches are pointers. To get yourself to a branch you need to <em>checkout</em> there</p>
<ul>
<li>create a new branch</li>
</ul>
<pre class="language-s"><code class="language-s">git branch new_branch
</code></pre>
<ul>
<li>go to the branch</li>
</ul>
<pre class="language-s"><code class="language-s">git checkout new_branch
</code></pre>
<ul>
<li>shortcut</li>
</ul>
<pre class="language-s"><code class="language-s">git checkout -b new_branch
</code></pre>
<h1 id="merge">Merge<a aria-hidden="true" class="anchor-heading icon-link" href="#merge"></a></h1>
<p><strong>Merge</strong> = combining work from two different branches together.</p>
<p>Merging in Git creates a special commit that has two unique parents.</p>
<p><img src="/dendron-wiki/assets/images/before_merge.png" alt="before_merge.png"></p>
<p><img src="/dendron-wiki/assets/images/after_merge.png" alt="after_merge.png"></p>
<p>Above we merge bugFix into main and main contains all the work.</p>
<ul>
<li>merge</li>
</ul>
<pre class="language-s"><code class="language-s">git checkout -b bugFix
git commit -m 'Blah'
git checkout main
git merge bugFix
</code></pre>
<h1 id="rebase">Rebase<a aria-hidden="true" class="anchor-heading icon-link" href="#rebase"></a></h1>
<p>The second way of combining work between branches is <strong>rebasing</strong>. Rebasing essentially takes a set of commits, "copies" them, and plops them down somewhere else.</p>
<p>Rebasing makes a nice linear sqauce of commits. Commit log of the repo will be cleaner.</p>
<p><img src="/dendron-wiki/assets/images/before_rebase.png" alt="before_rebase.png"></p>
<p><img src="/dendron-wiki/assets/images/after_rebase.png" alt="after_rebase.png"></p>
<p>Here we have two branches yet again; note that the bugFix branch is currently selected (note the asterisk)</p>
<p>We would like to move our work from bugFix directly onto the work from main. That way it would look like these two features were developed sequentially, when in reality they were developed in parallel.</p>
<p>C3 still exists, and the rebase creates a copy C3'</p>
<ul>
<li><strong>rebase</strong></li>
</ul>
<pre class="language-s"><code class="language-s">git checkout -b bugFix
git commit -m 'Blah'
git checkout main
git commit
git checkout bugFix
git rebase main
</code></pre>
<ul>
<li>interactive rebase (can squash commits)</li>
</ul>
<pre class="language-s"><code class="language-s">git rebase -i main
</code></pre>
<h1 id="head">HEAD<a aria-hidden="true" class="anchor-heading icon-link" href="#head"></a></h1>
<p><strong>HEAD</strong> is the symbolic name for the currently checked out commit -- it's essentially what commit you're working on top of.</p>
<p>HEAD is hiding underneath our work on the repo/branches.</p>
<p>HEAD normally point to the branch you are currently working on</p>
<p><strong>Detaching</strong> HEAD just means attaching it to a commit instead of a branch.</p>
<p>Example: on main branch with one commit:</p>
<p>HEAD -> main -> C1</p>
<p><code>git checkout C1 </code> makes HEAD ->  C1</p>
<p>To checkout to a commit you need to use its hash (C1)</p>
<p>To see commits hashes:</p>
<pre class="language-s"><code class="language-s">git log
</code></pre>
<h1 id="moving-around-git">Moving around git<a aria-hidden="true" class="anchor-heading icon-link" href="#moving-around-git"></a></h1>
<p>OPERATORS <code>^ ~</code></p>
<p>Specifying commits by their hash isn't the most convenient thing ever, which is why Git has relative refs</p>
<p>saying <strong>main^</strong> is equivalent to "the first parent of main</p>
<ul>
<li>go to parent commit</li>
</ul>
<pre class="language-s"><code class="language-s">git checkout main^
</code></pre>
<p>You can also reference HEAD as a relative ref</p>
<pre class="language-s"><code class="language-s">git checkout HEAD^
</code></pre>
<ul>
<li>go to previous commit, if current commit is C4, the one below will go to C0</li>
</ul>
<pre class="language-s"><code class="language-s">git checkout HEAD~4
</code></pre>
<p><strong>Advanced moving when there is a merge</strong></p>
<p><img src="/dendron-wiki/assets/images/move_up_adv_0.png" alt="move_up_adv_0.png">
<img src="/dendron-wiki/assets/images/move_up_adv.png" alt="move_up_adv.png"></p>
<h1 id="branch-forcing">Branch forcing<a aria-hidden="true" class="anchor-heading icon-link" href="#branch-forcing"></a></h1>
<p>One of the most common ways I use relative refs is to move branches around. You can directly r<strong>eassign a branch to a commit</strong> with the -f option</p>
<pre class="language-s"><code class="language-s">git branch -f main HEAD~3
</code></pre>
<p><img src="/dendron-wiki/assets/images/before_force.png" alt="before_force.png"></p>
<p><img src="/dendron-wiki/assets/images/after_force.png" alt="after_force.png"></p>
<h1 id="reversing-changes-in-git">Reversing changes in Git<a aria-hidden="true" class="anchor-heading icon-link" href="#reversing-changes-in-git"></a></h1>
<p><code>git reset</code> reverses changes by moving a branch reference backwards in time to an older commit. In this sense you can think of it as "rewriting history;" <code>git reset</code>will move a branch backwards as if the commit had never been made in the first place.</p>
<p><img src="/dendron-wiki/assets/images/before_reset.png" alt="before_reset.png"></p>
<p><img src="/dendron-wiki/assets/images/after_reset.png" alt="after_reset.png"></p>
<pre class="language-s"><code class="language-s">git reset HEAD~1
</code></pre>
<p>reset does not work for remote branches. Need to use</p>
<pre class="language-s"><code class="language-s">git revert HEAD
</code></pre>
<h1 id="moving-work-around">Moving Work Around<a aria-hidden="true" class="anchor-heading icon-link" href="#moving-work-around"></a></h1>
<p>You know how to move around the source tree using reference operators <code>^ ~</code>.</p>
<p>The next concept we're going to cover is "moving work around" -- in other words, it's a way for developers to say "I want this work here and that work there"</p>
<ul>
<li><strong> pick</strong></li>
</ul>
<pre class="language-s"><code class="language-s">git cherry-pick &#x3C;Commit1>&#x3C;Commit2>
</code></pre>
<p>says that you would like to copy a series of commits below your current location (HEAD).</p>
<ul>
<li><strong>interactive rebase</strong></li>
</ul>
<pre class="language-s"><code class="language-s">git rebase -i branch_name
</code></pre>
<p>Your current HEAD would copy from branch_name and do a rebase.</p>
<p>In interactive rebase you can <strong>reorder, omit, squash, change commit messages</strong>.</p>
<p>alternatively using references:</p>
<pre class="language-s"><code class="language-s">git rebase -i HEAD~3
</code></pre>
<p>Juggle commits: Say you want to make changes to an older commit but still keep the order. </p>
<p>Trick: Interactive rebase, then reorder, then make changes, reorder again.   </p>
<h1 id="git-tags">Git Tags<a aria-hidden="true" class="anchor-heading icon-link" href="#git-tags"></a></h1>
<p>Branches are easily mutated, often temporary, and always changing. You can move them around and refer to different commits. We use <strong>tags</strong> to permanently mark historical points in your project's history - major releases and big merges.</p>
<p>Tags never move, even if you create new commits.</p>
<pre class="language-s"><code class="language-s">git tag v1 commit_hash
</code></pre>
<p>tags serve as an anchor point:</p>
<pre class="language-s"><code class="language-s">git checkout v1
</code></pre>
<p><strong>git describe</strong></p>
<p>Because tags serve as such great "anchors" in the codebase, git has a command to describe where you are relative to the closest "anchor" (aka tag). And that command is called git describe</p>
<pre class="language-s"><code class="language-s">git describe &#x3C;ref>
</code></pre>
<p>Where <code>&#x3C;ref></code> is anything git can resolve into a commit. If you don't specify a ref, git just uses where you're checked out right now (<code>HEAD</code>).</p>
<p>The output of the command looks like:</p>
<p><code>&#x3C;tag>_&#x3C;numCommits>_g&#x3C;hash></code></p>
<p>Where <code>tag</code> is the closest ancestor tag in history, <code>numCommits</code> is how many commits away that tag is, and <code>&#x3C;hash></code> is the hash of the commit being described.</p>
<h1 id="git-remotes">Git Remotes<a aria-hidden="true" class="anchor-heading icon-link" href="#git-remotes"></a></h1>
<p>Git remotes are actually just copies of your repository on another computer. You can typically talk to this other computer through the Internet, which allows you to transfer commits back and forth.</p>
<ul>
<li>
<p>remotes serve as a great backup</p>
</li>
<li>
<p>remotes make coding social</p>
</li>
<li>
<p>create local copy of remote repositories</p>
</li>
</ul>
<pre><code>git clone
</code></pre>
<p>on your local you iwll have branches: <code>main</code> and <code>origin/main</code> (the remote branch)</p>
<p>Remote branches reflect the state of remote repositories</p>
<p>Remote branches have the special property that when you check them out, you are put into detached <code>HEAD</code> mode. <strong>Git does this on purpose because you can't work on these branches directly.</strong></p>
<pre><code>git fetch
</code></pre>
<p>git fetch performs two main steps, and two main steps:</p>
<ul>
<li>downloads the commits that the remote has but are missing from our local</li>
<li>updates where our remote branches point</li>
</ul>
<p>NB: fetch does <strong>not</strong> update branches</p>
<p>To reflect those changes  -- once you have new commits available locally you can do git merge <code>o/main</code></p>
<p>These two steps are incorporated in</p>
<pre><code>git pull
</code></pre>
<h1 id="collaborative-development-models">Collaborative development models<a aria-hidden="true" class="anchor-heading icon-link" href="#collaborative-development-models"></a></h1>
<p><a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/getting-started/about-collaborative-development-models">Shared repo model vs Fork and pull model</a></p>
<p>In a shared repository model, developers work on a single repository. All contributors have write access and crete Pull Requests to merge into main. It is best when you work in smaller teams and private repo.</p>
<p>In fork and pull model, developers for the main repository and can independently work on their fork. They can create branches, merge into the forked main and work independently. If they want to make changes to the upstream repo they will need to create a Pull Request. Only the maintainers of the repo have write access.</p>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/dendron-wiki/notes/4vzvi1b96nq3mqii7jmjwpp">How was Yelp built?</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#resources" title="Resources:">Resources:</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#commits-and-branches" title="Commits and branches">Commits and branches</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#merge" title="Merge">Merge</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#rebase" title="Rebase">Rebase</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#head" title="HEAD">HEAD</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#moving-around-git" title="Moving around git">Moving around git</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#branch-forcing" title="Branch forcing">Branch forcing</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#reversing-changes-in-git" title="Reversing changes in Git">Reversing changes in Git</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#moving-work-around" title="Moving Work Around">Moving Work Around</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#git-tags" title="Git Tags">Git Tags</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#git-remotes" title="Git Remotes">Git Remotes</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#collaborative-development-models" title="Collaborative development models">Collaborative development models</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"78ld05rlq10336r34dz8sxc","title":"Git","desc":"","updated":1744623890061,"created":1668288491690,"custom":{},"fname":"engineering.GIT","type":"note","vault":{"fsPath":"vault"},"contentHash":"ad316e85c193b41d9e6491ad2f25787c","links":[{"from":{"fname":"work.Yelp.How was Yelp built?","id":"4vzvi1b96nq3mqii7jmjwpp","vaultName":"vault"},"type":"backlink","position":{"start":{"line":12,"column":319,"offset":1864},"end":{"line":12,"column":338,"offset":1883},"indent":[]},"value":"engineering.git"}],"anchors":{"resources":{"type":"header","text":"Resources:","value":"resources","line":8,"column":0,"depth":1},"commits-and-branches":{"type":"header","text":"Commits and branches","value":"commits-and-branches","line":13,"column":0,"depth":1},"merge":{"type":"header","text":"Merge","value":"merge","line":49,"column":0,"depth":1},"rebase":{"type":"header","text":"Rebase","value":"rebase","line":70,"column":0,"depth":1},"head":{"type":"header","text":"HEAD","value":"head","line":104,"column":0,"depth":1},"moving-around-git":{"type":"header","text":"Moving around git","value":"moving-around-git","line":128,"column":0,"depth":1},"branch-forcing":{"type":"header","text":"Branch forcing","value":"branch-forcing","line":155,"column":0,"depth":1},"reversing-changes-in-git":{"type":"header","text":"Reversing changes in Git","value":"reversing-changes-in-git","line":168,"column":0,"depth":1},"moving-work-around":{"type":"header","text":"Moving Work Around","value":"moving-work-around","line":188,"column":0,"depth":1},"git-tags":{"type":"header","text":"Git Tags","value":"git-tags","line":222,"column":0,"depth":1},"git-remotes":{"type":"header","text":"Git Remotes","value":"git-remotes","line":254,"column":0,"depth":1},"collaborative-development-models":{"type":"header","text":"Collaborative development models","value":"collaborative-development-models","line":289,"column":0,"depth":1}},"children":[],"parent":"6bx5plramu4hksomqc1n55z","data":{}},"body":"\u003ch1 id=\"git\"\u003eGit\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#git\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003ch1 id=\"resources\"\u003eResources:\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#resources\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://learngitbranching.js.org/\"\u003eLearn Git Branching\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://git.github.io/git-reference/creating/#init\"\u003eGit reference common commands\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"commits-and-branches\"\u003eCommits and branches\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#commits-and-branches\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eA \u003cstrong\u003ecommit\u003c/strong\u003e in a git repository records a snapshot of all the (tracked) files in your directory. It's like a giant copy and paste, but even better!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ecommit = snapshot of the project = lightweight safe of project state\u003c/strong\u003e \u003c/p\u003e\n\u003cp\u003eCommits can be visually represented as nodes.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecreate a commit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit commit -m 'commit message'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBranches = pointer to a specific commit\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e'branch early, and branch often'\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eBranches are super lightweight and have no storage/memory overhead\u003c/p\u003e\n\u003cp\u003eBranches are pointers. To get yourself to a branch you need to \u003cem\u003echeckout\u003c/em\u003e there\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecreate a new branch\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit branch new_branch\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ego to the branch\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout new_branch\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eshortcut\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout -b new_branch\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"merge\"\u003eMerge\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#merge\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eMerge\u003c/strong\u003e = combining work from two different branches together.\u003c/p\u003e\n\u003cp\u003eMerging in Git creates a special commit that has two unique parents.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/before_merge.png\" alt=\"before_merge.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/after_merge.png\" alt=\"after_merge.png\"\u003e\u003c/p\u003e\n\u003cp\u003eAbove we merge bugFix into main and main contains all the work.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emerge\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout -b bugFix\ngit commit -m 'Blah'\ngit checkout main\ngit merge bugFix\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"rebase\"\u003eRebase\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rebase\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eThe second way of combining work between branches is \u003cstrong\u003erebasing\u003c/strong\u003e. Rebasing essentially takes a set of commits, \"copies\" them, and plops them down somewhere else.\u003c/p\u003e\n\u003cp\u003eRebasing makes a nice linear sqauce of commits. Commit log of the repo will be cleaner.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/before_rebase.png\" alt=\"before_rebase.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/after_rebase.png\" alt=\"after_rebase.png\"\u003e\u003c/p\u003e\n\u003cp\u003eHere we have two branches yet again; note that the bugFix branch is currently selected (note the asterisk)\u003c/p\u003e\n\u003cp\u003eWe would like to move our work from bugFix directly onto the work from main. That way it would look like these two features were developed sequentially, when in reality they were developed in parallel.\u003c/p\u003e\n\u003cp\u003eC3 still exists, and the rebase creates a copy C3'\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003erebase\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout -b bugFix\ngit commit -m 'Blah'\ngit checkout main\ngit commit\ngit checkout bugFix\ngit rebase main\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003einteractive rebase (can squash commits)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit rebase -i main\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"head\"\u003eHEAD\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#head\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eHEAD\u003c/strong\u003e is the symbolic name for the currently checked out commit -- it's essentially what commit you're working on top of.\u003c/p\u003e\n\u003cp\u003eHEAD is hiding underneath our work on the repo/branches.\u003c/p\u003e\n\u003cp\u003eHEAD normally point to the branch you are currently working on\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDetaching\u003c/strong\u003e HEAD just means attaching it to a commit instead of a branch.\u003c/p\u003e\n\u003cp\u003eExample: on main branch with one commit:\u003c/p\u003e\n\u003cp\u003eHEAD -\u003e main -\u003e C1\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit checkout C1 \u003c/code\u003e makes HEAD -\u003e  C1\u003c/p\u003e\n\u003cp\u003eTo checkout to a commit you need to use its hash (C1)\u003c/p\u003e\n\u003cp\u003eTo see commits hashes:\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit log\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"moving-around-git\"\u003eMoving around git\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#moving-around-git\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eOPERATORS \u003ccode\u003e^ ~\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eSpecifying commits by their hash isn't the most convenient thing ever, which is why Git has relative refs\u003c/p\u003e\n\u003cp\u003esaying \u003cstrong\u003emain^\u003c/strong\u003e is equivalent to \"the first parent of main\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ego to parent commit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout main^\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can also reference HEAD as a relative ref\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout HEAD^\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ego to previous commit, if current commit is C4, the one below will go to C0\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout HEAD~4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAdvanced moving when there is a merge\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/move_up_adv_0.png\" alt=\"move_up_adv_0.png\"\u003e\n\u003cimg src=\"/dendron-wiki/assets/images/move_up_adv.png\" alt=\"move_up_adv.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"branch-forcing\"\u003eBranch forcing\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#branch-forcing\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eOne of the most common ways I use relative refs is to move branches around. You can directly r\u003cstrong\u003eeassign a branch to a commit\u003c/strong\u003e with the -f option\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit branch -f main HEAD~3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/before_force.png\" alt=\"before_force.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/after_force.png\" alt=\"after_force.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"reversing-changes-in-git\"\u003eReversing changes in Git\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#reversing-changes-in-git\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003egit reset\u003c/code\u003e reverses changes by moving a branch reference backwards in time to an older commit. In this sense you can think of it as \"rewriting history;\" \u003ccode\u003egit reset\u003c/code\u003ewill move a branch backwards as if the commit had never been made in the first place.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/before_reset.png\" alt=\"before_reset.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/dendron-wiki/assets/images/after_reset.png\" alt=\"after_reset.png\"\u003e\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit reset HEAD~1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ereset does not work for remote branches. Need to use\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit revert HEAD\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"moving-work-around\"\u003eMoving Work Around\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#moving-work-around\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eYou know how to move around the source tree using reference operators \u003ccode\u003e^ ~\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe next concept we're going to cover is \"moving work around\" -- in other words, it's a way for developers to say \"I want this work here and that work there\"\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e pick\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit cherry-pick \u0026#x3C;Commit1\u003e\u0026#x3C;Commit2\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esays that you would like to copy a series of commits below your current location (HEAD).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003einteractive rebase\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit rebase -i branch_name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYour current HEAD would copy from branch_name and do a rebase.\u003c/p\u003e\n\u003cp\u003eIn interactive rebase you can \u003cstrong\u003ereorder, omit, squash, change commit messages\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ealternatively using references:\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit rebase -i HEAD~3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJuggle commits: Say you want to make changes to an older commit but still keep the order. \u003c/p\u003e\n\u003cp\u003eTrick: Interactive rebase, then reorder, then make changes, reorder again.   \u003c/p\u003e\n\u003ch1 id=\"git-tags\"\u003eGit Tags\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#git-tags\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eBranches are easily mutated, often temporary, and always changing. You can move them around and refer to different commits. We use \u003cstrong\u003etags\u003c/strong\u003e to permanently mark historical points in your project's history - major releases and big merges.\u003c/p\u003e\n\u003cp\u003eTags never move, even if you create new commits.\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit tag v1 commit_hash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etags serve as an anchor point:\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit checkout v1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003egit describe\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBecause tags serve as such great \"anchors\" in the codebase, git has a command to describe where you are relative to the closest \"anchor\" (aka tag). And that command is called git describe\u003c/p\u003e\n\u003cpre class=\"language-s\"\u003e\u003ccode class=\"language-s\"\u003egit describe \u0026#x3C;ref\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere \u003ccode\u003e\u0026#x3C;ref\u003e\u003c/code\u003e is anything git can resolve into a commit. If you don't specify a ref, git just uses where you're checked out right now (\u003ccode\u003eHEAD\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThe output of the command looks like:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;tag\u003e_\u0026#x3C;numCommits\u003e_g\u0026#x3C;hash\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWhere \u003ccode\u003etag\u003c/code\u003e is the closest ancestor tag in history, \u003ccode\u003enumCommits\u003c/code\u003e is how many commits away that tag is, and \u003ccode\u003e\u0026#x3C;hash\u003e\u003c/code\u003e is the hash of the commit being described.\u003c/p\u003e\n\u003ch1 id=\"git-remotes\"\u003eGit Remotes\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#git-remotes\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eGit remotes are actually just copies of your repository on another computer. You can typically talk to this other computer through the Internet, which allows you to transfer commits back and forth.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eremotes serve as a great backup\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eremotes make coding social\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ecreate local copy of remote repositories\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003egit clone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eon your local you iwll have branches: \u003ccode\u003emain\u003c/code\u003e and \u003ccode\u003eorigin/main\u003c/code\u003e (the remote branch)\u003c/p\u003e\n\u003cp\u003eRemote branches reflect the state of remote repositories\u003c/p\u003e\n\u003cp\u003eRemote branches have the special property that when you check them out, you are put into detached \u003ccode\u003eHEAD\u003c/code\u003e mode. \u003cstrong\u003eGit does this on purpose because you can't work on these branches directly.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egit fetch\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egit fetch performs two main steps, and two main steps:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edownloads the commits that the remote has but are missing from our local\u003c/li\u003e\n\u003cli\u003eupdates where our remote branches point\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNB: fetch does \u003cstrong\u003enot\u003c/strong\u003e update branches\u003c/p\u003e\n\u003cp\u003eTo reflect those changes  -- once you have new commits available locally you can do git merge \u003ccode\u003eo/main\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThese two steps are incorporated in\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egit pull\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"collaborative-development-models\"\u003eCollaborative development models\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#collaborative-development-models\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/getting-started/about-collaborative-development-models\"\u003eShared repo model vs Fork and pull model\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIn a shared repository model, developers work on a single repository. All contributors have write access and crete Pull Requests to merge into main. It is best when you work in smaller teams and private repo.\u003c/p\u003e\n\u003cp\u003eIn fork and pull model, developers for the main repository and can independently work on their fork. They can create branches, merge into the forked main and work independently. If they want to make changes to the upstream repo they will need to create a Pull Request. Only the maintainers of the repo have write access.\u003c/p\u003e\n\u003chr\u003e\n\u003cstrong\u003eBacklinks\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/dendron-wiki/notes/4vzvi1b96nq3mqii7jmjwpp\"\u003eHow was Yelp built?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"wn8PE1RhG0znK1alrGFYv","title":"Root","desc":"","updated":1763992060664,"created":1631901573363,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"dc095b340c158394d643b84f8585ff0c","links":[],"anchors":{},"children":["dgcsvcwea8scgdegrk9tfni","xig93vo47ou1bkr7s4w1wb2","ro9bbyftsutm88mxw6r16p5","ypia1zmywsklpicmcgrzlz1","w7iitlako61ppm27mym400a","6bx5plramu4hksomqc1n55z","4nki3bedlvs3mnkixj3a07k","9r5ym61dkwap92fvbte1jkq","849u97nrsuyekmr4a1r92ux","2b5bwf46z6v132wu7xghvrp","dygp5h2vzw4mkromwmofynb","7h50s7ga5ziiyblmoctsqmw","pglaolxcge4xfvgoph3je89","uy9u1co5ih1fokind8tg0eq","jc23ggp8iiu92kpnzo721to","f1u2a47guuw70olv36bzf66","c1bs7wsjfbhb0zipaywqv1","2av385tcj2cbumxprsauff3","lw1b4r6ykimvj9208nkgzps"],"parent":null,"data":{},"body":"\nZdr bebce kp ;)\n\nThis is my knowledge base, additionally I keep [daily journal](https://docs.google.com/document/d/1m8Npu0-t8RweyKiHCjLL1PPDYzbebqm3OZDHH8IVsb8/edit?tab=t.rj0kvkrm7zpr)."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableUserTags":true,"enableHashTags":true,"dendronVersion":"0.95.0","enableEditorDecorations":true,"enableFullHierarchyNoteTitle":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","assetsPrefix":"/dendron-wiki","siteUrl":"https://ngocuong0105.github.io","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"theme":"light","templateVersion":"0.97.0","ga":{"tracking":"G-W5DRRLQ1N7"},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"78ld05rlq10336r34dz8sxc"},"buildId":"AZXonBxzXDJ7mmxS9Br0O","assetPrefix":"/dendron-wiki","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>