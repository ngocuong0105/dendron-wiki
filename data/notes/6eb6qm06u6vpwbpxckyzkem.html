<h1 id="stanford-cs230-deep-learning">Stanford CS230: Deep Learning<a aria-hidden="true" class="anchor-heading icon-link" href="#stanford-cs230-deep-learning"></a></h1>
<p><a href="https://www.youtube.com/playlist?list=PLoROMvodv4rOABXSygHTsbvUz4G_YQhOb">Stanford DL course</a></p>
<p><a href="http://cs230.stanford.edu/syllabus/">Syllabus</a></p>
<p>This course is youtube videos + coursera videos. Youtube has deeper insights and coursera is for practice and fundamentals.</p>
<h1 id="key-messages">Key messages<a aria-hidden="true" class="anchor-heading icon-link" href="#key-messages"></a></h1>
<ul>
<li>In deep learning, feature learning replaces feature engineering</li>
<li>Traditional ML performance <strong>platues</strong> at some point and cannnot utilize more data. For NN we have not reached that point yet.</li>
<li>ML,DL is all about approximating/learning a function.</li>
<li>Model = Architecture + Parameters</li>
<li>Gradient evaluated at particular point = slope of the tangent at particular point</li>
<li>Gradient checking (e.g if the signs changes often) is a good way to see if your optimization of the loss function is divergent.</li>
<li>Backprogation is just an application of the chain rule.</li>
<li>Backpropagation is used to calculate the gradient of the loss function with respect to the parameters. </li>
<li>ReLU is the most common activation function</li>
<li>Sigmoid is almost never used for hidden layers, tanh is almost always better choice</li>
<li>NN require random initialization</li>
<li>Aim to have yur validation and test set coming from the same distribution.</li>
<li>L2 regularization is also called weight decay <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi>α</mi><mi>λ</mi></mrow><mi>n</mi></mfrac></mstyle><mo stretchy="false">)</mo><mi>w</mi><mo>−</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">w = (1-\dfrac{\alpha\lambda}{n})w - other terms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></li>
<li>Sanity checks for your NN:
<ul>
<li>cost is decreasing as number of iterations increase (if using dropout, might not be the case)</li>
<li>gradient checking  </li>
</ul>
</li>
<li>Regularization is used to reduce overfitting
<ul>
<li>L1, L2</li>
<li>Dropout</li>
<li>Data augmentation (add more data, rotate image, add some noise, flip image, blur image )</li>
<li>Early stopping</li>
</ul>
</li>
<li>Orthogonalisation idea one task at a time. (First focus on minimizing the cost function (overfit!). Then focus on regularization.)</li>
<li>Normalize inputs for NN to converge more quickly</li>
<li>Careful choice of weights initialization can solve vanishing/exploding gradients</li>
<li>Gradient tracking</li>
<li><a href="https://arxiv.org/abs/1502.01852">https://arxiv.org/abs/1502.01852</a></li>
</ul>
<h1 id="lecture-1-deep-learning-overview">Lecture 1 Deep Learning overview<a aria-hidden="true" class="anchor-heading icon-link" href="#lecture-1-deep-learning-overview"></a></h1>
<p>Deep Learning and Neural Network are almost the same thing. DL is the popular brand word.</p>
<p>Traditional ML performance <strong>platues</strong> at some point and cannnot utilize more data. For NN we have not reached that point yet.</p>
<p><img src="/dendron-wiki/assets/images/ML_DL_performance.png"></p>
<p><strong>Fundamental courses:</strong></p>
<ul>
<li>CS229 (ML most mathematical)</li>
<li>CS299A (Applied ML least mathematical and easiest)</li>
<li>CS230 (a bit in between, focuses on DL)</li>
</ul>
<p>Finish C1M1, C1M2 (chap 1 module 2).</p>
<h1 id="lecture-2-deep-learning-intuition">Lecture 2: Deep Learning Intuition<a aria-hidden="true" class="anchor-heading icon-link" href="#lecture-2-deep-learning-intuition"></a></h1>
<p>ML,DL is all about approximating/learning a function.</p>
<p><strong>Model = Architecture + Parameters</strong></p>
<p>The goal of ML/DL is to find the best parameters for the model.</p>
<p>Example:</p>
<p><img src="/dendron-wiki/assets/images/lg_nn.png"></p>
<p><strong>Each hidden layer encodes information from previous layer. E.g in convolutional neural network, each layer encodes more and more complex features. </strong></p>
<p><img src="/dendron-wiki/assets/images/cnn_encoding.png"></p>
<h2 id="case-study-1-day-and-night-classification">Case study 1: Day and Night classification<a aria-hidden="true" class="anchor-heading icon-link" href="#case-study-1-day-and-night-classification"></a></h2>
<p><strong>Deep Learning Project choices:</strong></p>
<p><img src="/dendron-wiki/assets/images/dl_choices.png"></p>
<p>The problem of clasifying a cat needed 10,000 images. Is the next problem easier or harder? Depending  on the task you want to solve you would know based on past projets how many data point you need.</p>
<ul>
<li>train/test split 80/20 is good for 10k images. If I had 1M images I would choose 98/2 split. Test data is to gauge how well the model is doing on real unseen data. You ask yourself how many data points I need to tell my model is doing good (dawn, sunset, sunrise, evening, morning)</li>
<li>bias you want balanced dataset in train and test</li>
<li>resolution of images (the smaller the better for computation. 32x32 is better than 400x400) Choose the smallest resolution that human can have perfect performance. If you had unlimited computational power you would choose the highest resolution.</li>
</ul>
<h2 id="case-study-2-face-verification">Case study 2: Face verification<a aria-hidden="true" class="anchor-heading icon-link" href="#case-study-2-face-verification"></a></h2>
<ul>
<li>architecture: encode each image using a DL and then compute distance functions</li>
<li>In face verification, we have used an encoder network to learn a lower
dimensional representation (called “encoding”) for a set of data by
training the network to focus on non-noisy signals.</li>
<li><strong>Triplet loss</strong> is a loss function where an (anchor) input is compared to a
positive input and a negative input. The distance from the anchor input to
the positive input is minimized, whereas the distance from the anchor input
to the negative input is maximized.</li>
</ul>
<p><img src="/dendron-wiki/assets/images/face_verify1.png"></p>
<p><img src="/dendron-wiki/assets/images/face_verify2.png"></p>
<p><img src="/dendron-wiki/assets/images/face_verify3.png"></p>
<h2 id="case-study-3-art-generation">Case study 3: Art generation<a aria-hidden="true" class="anchor-heading icon-link" href="#case-study-3-art-generation"></a></h2>
<ul>
<li>Do not train model, just optimize the cost function by changing pixels (goal is to generate image)
Kian Katanforoosh</li>
<li>In the neural style transfer algorithm proposed by Gatys et al., you optimize
image pixels rather than model parameters. Model parameters are
pretrained and non-trainable.</li>
<li>You leverage the “knowledge” of a pretrained model to extract the content
of a content image and the style of a style image</li>
<li>ImageNet</li>
<li>Take gradient of loss function with respect to the pixels <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>.</li>
</ul>
<p><img src="/dendron-wiki/assets/images/art_gen1.png"></p>
<p><img src="/dendron-wiki/assets/images/art_gen2.png"></p>
<p><img src="/dendron-wiki/assets/images/art_gen3.png"></p>
<h2 id="case-study-4-trigger-word-detection-alexa">Case study 4: Trigger word detection (Alexa)<a aria-hidden="true" class="anchor-heading icon-link" href="#case-study-4-trigger-word-detection-alexa"></a></h2>
<ul>
<li>Your data collection strategy is critical to the success of your project. (If
applicable) Don’t hesitate to get out of the building.</li>
<li>You can gain insights on your labelling strategy by using a human experiment</li>
</ul>
<p><img src="/dendron-wiki/assets/images/trigger_word.png"></p>
<p><img src="/dendron-wiki/assets/images/data_collection.png"></p>
<h1 id="lecture-3---full-cycle-deep-learning-projects">Lecture 3 - Full-Cycle Deep Learning Projects<a aria-hidden="true" class="anchor-heading icon-link" href="#lecture-3---full-cycle-deep-learning-projects"></a></h1>
<ol>
<li>Select problem (e.g. supervised learning)</li>
<li>Get data (need to be very strategic in that)</li>
<li>Design model</li>
<li>Train model (iterative process with point 2 and 3)</li>
<li>Test model</li>
<li>Deploy</li>
<li>Maintain</li>
</ol>
<p>Five points when selecting a project:</p>
<ul>
<li>interest</li>
<li>data availability</li>
<li>domain knowledge</li>
<li>feasibility</li>
<li>Usefulness</li>
</ul>
<p>First goal when starting to build a ML system is to get a baseline as fast as possible. Then iterate on that. That is steps 1-5 should be done within a couple of days.</p>
<p>ML developement is an iterative process. Before you start working on it it is difficult to know what are the hard problems you need to tackle</p>
<p><strong>Tips:</strong></p>
<ul>
<li>keep clear notes on experiments runs</li>
<li>generally when you have to make choice between multiple options - go with the simpler one first</li>
<li>in real projects often data change over time. Non-ML models are more robust, ML models often need to be retrained.</li>
</ul>
<p>edge deployment vs cloud deployment</p>
<h1 id="lecture-4---adversarial-attacks--gans">Lecture 4 - Adversarial Attacks / GANs<a aria-hidden="true" class="anchor-heading icon-link" href="#lecture-4---adversarial-attacks--gans"></a></h1>
<p><strong>Discovery: Several ML models, including state-of-the-art neural networks are vulnerable to adversarial examples.</strong></p>
<p>[Szegedy et al. (2013): Intriguing properties of neural networks]</p>
<p>[Ian J. Goodfellow, Jonathon Shlens &#x26; Christian Szegedy (2015): Explaining and harnessing adversarial examples]</p>
<h2 id="attacking-a-network-with-adversarial-examples">Attacking a network with adversarial examples<a aria-hidden="true" class="anchor-heading icon-link" href="#attacking-a-network-with-adversarial-examples"></a></h2>
<p>What are examples of Adversarial attacks?</p>
<p>Given a network pretrained on ImageNet, find an input image that is not a iguana but will be classified as iguana.</p>
<p>Attack:</p>
<ol>
<li>Start with some image that is not iguana.</li>
<li>Use pretrained NN and output a vector of probabilities (cat, dog, iguana..)</li>
<li>Compute Loss.</li>
<li>Take gradient of loss wrt to the pixels. (backpropagation, need to have access to the model, parameters, layers etc.)</li>
<li>Change the image pixels.</li>
</ol>
<p><img src="/dendron-wiki/assets/images/adversarial_examples.png"></p>
<p>You can see that chaning with very little the pixels in the image you can fool the network that the cat is an iguana.</p>
<p><img src="/dendron-wiki/assets/images/space_images.png"></p>
<h2 id="defense-against-a-network-with-adversarial-examples">Defense against a network with adversarial examples<a aria-hidden="true" class="anchor-heading icon-link" href="#defense-against-a-network-with-adversarial-examples"></a></h2>
<ol>
<li>Add a SafetyNet - one more NN that will detect adversarial examples. (but it can be fooled as well) [Yuan et al. (2017): Adversarial Examples: Attacks and Defenses for Deep Learning]</li>
<li>Train on corrrectly labelled adversarial examples. Generate adversarial examples and train on them.</li>
</ol>
<h2 id="why-are-nn-vulnarable-to-adversarial-examples">Why are NN vulnarable to adversarial examples?<a aria-hidden="true" class="anchor-heading icon-link" href="#why-are-nn-vulnarable-to-adversarial-examples"></a></h2>
<p><a href="https://arxiv.org/pdf/1712.07107.pdf">Adversarial Examples: Attacks and Defenses for Deep Learning</a></p>
<p>You'd think that NN are vulnaraalbe because they are too complex and overfit the data. But it turns out that the linearity part of the network is the problem.</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><mi>w</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = xw+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>
<p>It is easy to create <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>=</mo><mi>x</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">x^{*}=x+\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span> which would produce massively different y.</p>
<p><strong>Fast Gradient Sign Method</strong> is a method to create quickly adversarial examples.</p>
<h2 id="gan---generative-adversarial-networks">GAN - Generative Adversarial Networks<a aria-hidden="true" class="anchor-heading icon-link" href="#gan---generative-adversarial-networks"></a></h2>
<p>The word adversarial is used in different meaning here. In GANs it means that there are two networks that are competing with each other.</p>
<p>GAN-s are networks that generate images that mimic the distribution of the real images/data.</p>
<h3 id="gd-game">G/D game<a aria-hidden="true" class="anchor-heading icon-link" href="#gd-game"></a></h3>
<p>Generator (is what we want to train and generate fake images),</p>
<p>Disriminator</p>
<p>G wants to fool D. D catches fake images. In the beginning it would be very good at catching fake images. But G will learn to generate better images. G and D are trained together.</p>
<p>Min-max trick of chaning the loss function</p>
<p>Saturating cost vs non-saturating cost </p>
<p>If D does not improve G cannot improve. You can see D as an upper bound on G.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">for</span> num_iterations<span class="token punctuation">:</span>
    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>
        update D
    update G
</code></pre>
<p>Tips for training GAN-s:</p>
<ul>
<li>modify loss function</li>
<li>keep D up-to-date with respect to G (k update for G and 1 update for D)</li>
<li>Virtual Batchnorm</li>
<li>one-sided label smoothing</li>
</ul>
<p>CycleGAN</p>
<p>image with horses, generate same image with zebra.</p>
<p>Loss function contains all losses from normal gans + cycle loss. </p>
<p><img src="/dendron-wiki/assets/images/cycle_gan.png"></p>