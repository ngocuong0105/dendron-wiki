<h1 id="graphs">Graphs<a aria-hidden="true" class="anchor-heading icon-link" href="#graphs"></a></h1>
<h1 id="graph-traversal">Graph traversal<a aria-hidden="true" class="anchor-heading icon-link" href="#graph-traversal"></a></h1>
<h2 id="breadth-first-search">Breadth First Search<a aria-hidden="true" class="anchor-heading icon-link" href="#breadth-first-search"></a></h2>
<ul>
<li><a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/?envType=study-plan&#x26;id=dynamic-programming-iv">visit all</a></li>
</ul>
<h2 id="depth-first-search">Depth First Search<a aria-hidden="true" class="anchor-heading icon-link" href="#depth-first-search"></a></h2>
<hr>
<h1 id="connected-components-bridges-articulations-points">Connected components, bridges, articulations points<a aria-hidden="true" class="anchor-heading icon-link" href="#connected-components-bridges-articulations-points"></a></h1>
<h2 id="finding-connected-components">Finding Connected Components<a aria-hidden="true" class="anchor-heading icon-link" href="#finding-connected-components"></a></h2>
<h2 id="finding-bridges-in-onm">Finding Bridges in O(N+M)<a aria-hidden="true" class="anchor-heading icon-link" href="#finding-bridges-in-onm"></a></h2>
<ul>
<li>find bridges in graph in linear time</li>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/">leetcode</a></li>
<li><a href="https://cp-algorithms.com/graph/bridge-searching.html#implementation">explanation</a></li>
<li>key: track entry times in array <code>tin</code>, and compute array <code>low</code>
<code>low[s]</code> is minimum of:
<pre><code>- entry time in s
- entry time in all descendants u of s which are back edges
- `low[u]` for all u where $(s,u)$ is tree edge
</code></pre>
</li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">bridges</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">nonlocal</span> t
        visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        t <span class="token operator">+=</span> <span class="token number">1</span>
        low<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> tin<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> t
        <span class="token keyword">for</span> u <span class="token keyword">in</span> adj_mat<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> u <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>u<span class="token punctuation">,</span>s<span class="token punctuation">)</span>
                low<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span>low<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> low<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> tin<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>s<span class="token punctuation">,</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">elif</span> u <span class="token operator">!=</span> p<span class="token punctuation">:</span>
                low<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span>tin<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
    res<span class="token punctuation">,</span>visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    t<span class="token punctuation">,</span>low<span class="token punctuation">,</span>tin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span>n<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span>n
    <span class="token keyword">for</span> s <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> s <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
            dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> res
</code></pre>
</details>
<h2 id="finding-bridges-online">Finding Bridges Online<a aria-hidden="true" class="anchor-heading icon-link" href="#finding-bridges-online"></a></h2>
<h2 id="finding-articulation-points-in-onm">Finding Articulation Points in <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></span><a aria-hidden="true" class="anchor-heading icon-link" href="#finding-articulation-points-in-onm"></a></h2>
<ul>
<li><a href="https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/">leetcode</a></li>
<li><a href="https://cp-algorithms.com/graph/cutpoints.html">explanation</a></li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">articulation_point</span><span class="token punctuation">(</span>adj<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">nonlocal</span> t
        visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        t <span class="token operator">+=</span> <span class="token number">1</span>
        tin<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> low<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> t
        children <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> u <span class="token keyword">in</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> u <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>u<span class="token punctuation">,</span>s<span class="token punctuation">)</span>
                low<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span>low<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> 
                <span class="token keyword">if</span> low<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">>=</span> tin<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token keyword">and</span> p<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment"># \geq !</span>
                    art<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
                children <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> u <span class="token operator">!=</span> p<span class="token punctuation">:</span>
                low<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span>tin<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>  
        <span class="token keyword">if</span> children <span class="token operator">!=</span> <span class="token number">1</span> <span class="token keyword">and</span> p<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
            art<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    t<span class="token punctuation">,</span>visited <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    tin<span class="token punctuation">,</span>low<span class="token punctuation">,</span>art <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> adj<span class="token punctuation">:</span>
        <span class="token keyword">if</span> s <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span> dfs<span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> art <span class="token operator">!=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            
</code></pre>
</details>
<ul>
<li><a href="https://leetcode.com/problems/minimize-malware-spread-ii/">malware spread</a>; can be solved using simple dfs/bfs for each node in <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>, use articulation points <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>, DSU <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li>
</ul>
<h2 id="strongly-connected-components-and-condensation-graph">Strongly Connected Components and Condensation Graph<a aria-hidden="true" class="anchor-heading icon-link" href="#strongly-connected-components-and-condensation-graph"></a></h2>
<h2 id="strong-orientation">Strong Orientation<a aria-hidden="true" class="anchor-heading icon-link" href="#strong-orientation"></a></h2>
<hr>
<h1 id="single-source-shortest-paths">Single-source shortest paths<a aria-hidden="true" class="anchor-heading icon-link" href="#single-source-shortest-paths"></a></h1>
<h2 id="dijkstra---finding-shortest-paths-from-given-vertex">Dijkstra - finding shortest paths from given vertex<a aria-hidden="true" class="anchor-heading icon-link" href="#dijkstra---finding-shortest-paths-from-given-vertex"></a></h2>
<ul>
<li>
<p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/?envType=study-plan&#x26;id=level-3">Cheapest flights within k stops</a></p>
</li>
<li>
<p><a href="https://leetcode.com/problems/modify-graph-edge-weights/">Modify edges, SMART Dijkstra application</a></p>
</li>
</ul>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span>
    dist<span class="token punctuation">,</span>parent <span class="token operator">=</span> <span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">while</span> h<span class="token punctuation">:</span>
        d<span class="token punctuation">,</span>s <span class="token operator">=</span> heappop<span class="token punctuation">(</span>h<span class="token punctuation">)</span>
        <span class="token keyword">for</span> u<span class="token punctuation">,</span>du <span class="token keyword">in</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dist<span class="token punctuation">.</span>get<span class="token punctuation">(</span>u<span class="token punctuation">,</span>inf<span class="token punctuation">)</span> <span class="token operator">></span> du<span class="token operator">+</span>d<span class="token punctuation">:</span>
                dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> du<span class="token operator">+</span>d
                parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> s
                heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">,</span>parent
</code></pre>
<p><strong>First loop on k, otherwise it will error. k is the phase count.</strong></p>
<h2 id="dijkstra-on-sparse-graphs">Dijkstra on sparse graphs<a aria-hidden="true" class="anchor-heading icon-link" href="#dijkstra-on-sparse-graphs"></a></h2>
<h2 id="bellman-ford---finding-shortest-paths-with-negative-weights">Bellman-Ford - finding shortest paths with negative weights<a aria-hidden="true" class="anchor-heading icon-link" href="#bellman-ford---finding-shortest-paths-with-negative-weights"></a></h2>
<h2 id="0-1-bfs">0-1 BFS<a aria-hidden="true" class="anchor-heading icon-link" href="#0-1-bfs"></a></h2>
<h2 id="desopo-pape-algorithm">D´Esopo-Pape algorithm<a aria-hidden="true" class="anchor-heading icon-link" href="#desopo-pape-algorithm"></a></h2>
<h1 id="all-pairs-shortest-paths">All-pairs shortest paths<a aria-hidden="true" class="anchor-heading icon-link" href="#all-pairs-shortest-paths"></a></h1>
<h2 id="floyd-warshall---finding-all-shortest-paths">Floyd-Warshall - finding all shortest paths<a aria-hidden="true" class="anchor-heading icon-link" href="#floyd-warshall---finding-all-shortest-paths"></a></h2>
<p><strong>NB: Order of the loops is important. MUST START WITH K that is the phase.</strong></p>
<p>Given a directed or an undirected weighted graph <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></span> with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> vertices.
The task is to find the length of the shortest path <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> between each pair of vertices <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>.</p>
<p>The graph may have negative weight edges, but no negative weight cycles.</p>
<p>The key idea of the algorithm is to partition the process of finding the shortest path between any two vertices to <strong>several incremental phases</strong>.</p>
<p>Let us number the vertices starting from 1 to <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>.
The matrix of distances is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[ ][ ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span></span>.</p>
<p>Before <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>-th phase (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>…</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k = 1 \dots n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></span>), <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span> for any vertices <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> stores the length of the shortest path between the vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>, which contains only the vertices <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, ..., k-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span> as internal vertices in the path.</p>
<p>In other words, before <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>-th phase the value of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span> is equal to the length of the shortest path from vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> to the vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>, if this path is allowed to enter <strong>only the vertex with numbers smaller than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span></strong> (the beginning and end of the path are not restricted by this property).</p>
<p>It is easy to make sure that this property holds for the first phase. For <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span>, we can fill matrix with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d[i][j] = w_{i j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> if there exists an edge between <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> with weight <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{i j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">d[i][j] = \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></span> if there doesn't exist an edge.</p>
<p>Suppose now that we are in the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>-th phase, and we want to compute the matrix <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[ ][ ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span></span> so that it meets the requirements for the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>-th phase.
We have to fix the distances for some vertices pairs <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span>.
There are two fundamentally different cases:</p>
<ul>
<li>
<p>The shortest way from the vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> to the vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> with internal vertices from the set <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, \dots, k\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">}</span></span></span></span></span> coincides with the shortest path with internal vertices from the set <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, \dots, k-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span>.</p>
<p>In this case, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span> will not change during the transition.</p>
</li>
<li>
<p>The shortest path with internal vertices from <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, \dots, k\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">}</span></span></span></span></span> is shorter.</p>
<p>This means that the new, shorter path passes through the vertex <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>.
This means that we can split the shortest path between <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> into two paths:
the path between <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>, and the path between <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>.
It is clear that both this paths only use internal vertices of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, \dots, k-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span> and are the shortest such paths in that respect.
Therefore we already have computed the lengths of those paths before, and we can compute the length of the shortest path between <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[i][k] + d[k][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span>.</p>
</li>
</ul>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="number-of-paths-of-fixed-length--shortest-paths-of-fixed-length">Number of paths of fixed length / Shortest paths of fixed length<a aria-hidden="true" class="anchor-heading icon-link" href="#number-of-paths-of-fixed-length--shortest-paths-of-fixed-length"></a></h2>
<h1 id="spanning-trees">Spanning trees<a aria-hidden="true" class="anchor-heading icon-link" href="#spanning-trees"></a></h1>
<pre><code>Minimum Spanning Tree - Prim's Algorithm
Minimum Spanning Tree - Kruskal
Minimum Spanning Tree - Kruskal with Disjoint Set Union
Second best Minimum Spanning Tree - Using Kruskal and Lowest Common Ancestor
Kirchhoff Theorem
Prüfer code
</code></pre>
<h1 id="cycles">Cycles<a aria-hidden="true" class="anchor-heading icon-link" href="#cycles"></a></h1>
<h2 id="checking-a-graph-for-acyclicity-and-finding-a-cycle-in-om">Checking a graph for acyclicity and finding a cycle in O(M)<a aria-hidden="true" class="anchor-heading icon-link" href="#checking-a-graph-for-acyclicity-and-finding-a-cycle-in-om"></a></h2>
<ul>
<li>nonlocal variables cycle and visited</li>
<li>keep path variable tracing the dfs</li>
<li>CLRS and CP algo use coloring, white, gray, black and nonlocal cycle variable (i think we cannot avoid nonlocal stuff)</li>
<li><strong>NB!!!</strong> below is for cycle in directed graph, for <strong>undirected</strong> need to keep parent pointers and make sure you when you go back to parent you don't consider it as cycle</li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">nonlocal</span> cycle
    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token keyword">for</span> u <span class="token keyword">in</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> u <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
            dfs<span class="token punctuation">(</span>u<span class="token punctuation">,</span>path<span class="token operator">|</span><span class="token punctuation">{</span>u<span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> u <span class="token keyword">in</span> path<span class="token punctuation">:</span>
            cycle <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">return</span>
cycle<span class="token punctuation">,</span>visited <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> s <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
        dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span>
</code></pre>
</details>
<ul>
<li>To get the nodes in the cycle you might keep a <code>parent</code> dictionary and do a while loop instead of marking cycle = True</li>
<li>Alternatively there is this trick to get the cycle nodes:</li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-python"><span class="token comment"># step 1: backtracking DFS to find the cycle</span>
circle <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
vis <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">find_circle</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> par<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> node <span class="token keyword">in</span> vis<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>
    <span class="token keyword">for</span> nei <span class="token keyword">in</span> g<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> nei <span class="token operator">==</span> par<span class="token punctuation">:</span> <span class="token keyword">continue</span>
        vis<span class="token punctuation">.</span>add<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        circle<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        status<span class="token punctuation">,</span> res <span class="token operator">=</span> find_circle<span class="token punctuation">(</span>nei<span class="token punctuation">,</span> node<span class="token punctuation">)</span>
        <span class="token keyword">if</span> status<span class="token punctuation">:</span> <span class="token keyword">return</span> status<span class="token punctuation">,</span> res
        circle<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        vis<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">None</span>


_<span class="token punctuation">,</span> node <span class="token operator">=</span> find_circle<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
<span class="token comment"># get the circle from start "node"</span>
circle <span class="token operator">=</span> circle<span class="token punctuation">[</span>circle<span class="token punctuation">.</span>index<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span> 
</code></pre>
</details>
<p><a class="color-tag" style="--tag-color: #ef4026;" href="/dendron-wiki/notes/2pzhpouodnn9fn9451isbr6">#QED</a></p>
<h2 id="finding-a-negative-cycle-in-the-graph">Finding a Negative Cycle in the Graph<a aria-hidden="true" class="anchor-heading icon-link" href="#finding-a-negative-cycle-in-the-graph"></a></h2>
<h2 id="eulerian-path">Eulerian Path<a aria-hidden="true" class="anchor-heading icon-link" href="#eulerian-path"></a></h2>
<p>Euler path</p>
<p>Eulerian Path is a path in a graph that visits every edge exactly once. </p>
<ul>
<li><a href="https://leetcode.com/problems/valid-arrangement-of-pairs/">leetcode</a></li>
</ul>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">hierholzer_recursive</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">visit</span><span class="token punctuation">(</span>vertex<span class="token punctuation">,</span> circuit<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> graph<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">:</span>
            next_vertex <span class="token operator">=</span> graph<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            visit<span class="token punctuation">(</span>next_vertex<span class="token punctuation">,</span> circuit<span class="token punctuation">)</span>
        circuit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>

    circuit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    start_vertex <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    visit<span class="token punctuation">(</span>start_vertex<span class="token punctuation">,</span> circuit<span class="token punctuation">)</span>
    circuit<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> circuit

</code></pre>
<p>To properly initialize the start vertex in the recursive version of Hierholzer's algorithm, you can modify the code to select a vertex with an odd degree (if one exists) as the starting point. This ensures that the algorithm will find an Eulerian circuit if one exists in the graph.</p>
<h1 id="lowest-common-ancestor">Lowest common ancestor<a aria-hidden="true" class="anchor-heading icon-link" href="#lowest-common-ancestor"></a></h1>
<h2 id="lowest-common-ancestor-1">Lowest Common Ancestor<a aria-hidden="true" class="anchor-heading icon-link" href="#lowest-common-ancestor-1"></a></h2>
<p>Given a tree <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></span> find the lowest common ancestor of two nodes <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>. If you have to do just once it is easy, see <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">lca</a></p>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">lca</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root <span class="token keyword">or</span> root <span class="token operator">==</span> p <span class="token keyword">or</span> root <span class="token operator">==</span> q<span class="token punctuation">:</span>
        <span class="token keyword">return</span> root
    l<span class="token punctuation">,</span>r <span class="token operator">=</span> lca<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>lca<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token keyword">if</span> l <span class="token keyword">and</span> r<span class="token punctuation">:</span> <span class="token keyword">return</span> root
    <span class="token keyword">return</span> l <span class="token keyword">if</span> l <span class="token keyword">else</span> r
</code></pre>
</details>
<p>More interesting is when you have <strong>queries</strong> <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u_i,v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>. Note lca lies on shortest path.</p>
<h2 id="hamiltonian-path">Hamiltonian path<a aria-hidden="true" class="anchor-heading icon-link" href="#hamiltonian-path"></a></h2>
<p>A Hamiltonian path or traceable path is a path that visits each vertex of the graph exactly once. A graph that contains a Hamiltonian path is called a traceable graph.</p>
<p>Whether Hamiltonian path exists in a graph or not is NP-complete problem.</p>
<h2 id="binary-lifting">Binary Lifting<a aria-hidden="true" class="anchor-heading icon-link" href="#binary-lifting"></a></h2>
<p><img src="/dendron-wiki/assets/images/o(logn).png"></p>
<p>With Binary tree lifting you can answer questions such as given a tree and a node inn the tree, what is its k-th ancestor.</p>
<p>Brute force is to repeat <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> times <code>v = parent[v]</code> -> complexity <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>Q</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Q * N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span> if we have <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span></span> queries and the tree is very deep.</p>
<p>Binary tree lifting is also known as jump pointers. <a href="https://www.youtube.com/watch?v=oib-XsjFa-M&#x26;t=579s&#x26;ab_channel=Errichto">Errihto</a>.</p>
<p><strong>There are <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> powers of 2.</strong></p>
<p><strong>Preprocessing</strong></p>
<p><strong>Define</strong> <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">u[v][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span> is the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></span>-th ancestor of v.</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">u[v][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span> is the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></span>-th ancestor of v.
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">u[v][0] = parent[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">re</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span></span> - that is my first parent
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>u</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">u[v][1] = u[u[v][0]][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span> - what is my second parent? first parent of my first parent
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mi>u</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">u[v][2] = u[u[v][1]][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> - what is my fourth parent? second parent of my second parent</p>
<p><code>u</code> is a map that tells me for each node what is the 1st, 2nd, 4th, 8th ... ancestor.</p>
<pre class="language-python"><code class="language-Python"><span class="token comment"># parent[i] if the parent of node i</span>
log <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">bin</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
parent<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># root</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>log<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> up<span class="token punctuation">[</span>up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        
<span class="token keyword">def</span> <span class="token function">getKthAncestor</span><span class="token punctuation">(</span>node<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token comment"># if depth[node] &#x3C; k: return -1</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> k <span class="token operator">&#x26;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&#x3C;&#x3C;</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>
            node <span class="token operator">=</span> up<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">return</span> node
</code></pre>
<p>careful with for loops, you might need <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3C;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">parent[i] &#x3C; i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">re</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&#x3C;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> to do preprocessing (computing) matrix <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span> (depending on your loop order).  </p>
<ul>
<li><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/">Kth ancestor</a> </li>
</ul>
<p><strong>Complexity:</strong> <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span> on preprocessing and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span> per query.</p>
<h2 id="lowest-common-ancestor---binary-lifting">Lowest Common Ancestor - Binary Lifting<a aria-hidden="true" class="anchor-heading icon-link" href="#lowest-common-ancestor---binary-lifting"></a></h2>
<p><strong>Lowest common ancestor</strong>
For queries with nodes <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> we want to get the lowest common ancestor of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>.</p>
<p>Idea: Run dfs, record for each nodes <code>timein</code> and <code>timeout</code>. This helps to answer if <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span> is ancestor ov <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> or vice versa.</p>
<p>Start from the top <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">up[u][L]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mclose">]</span></span></span></span></span> = the highest ancestor of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span>. Decrement <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></span> checking if <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">up[u][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span> is ancestor of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>. Goal is to find highest ancestor of u which is not ancestor of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>, return <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">up[u][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span>.</p>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">is_ancestor</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> timein<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&#x3C;=</span> timein<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token keyword">and</span> timeout<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">>=</span> timeout<span class="token punctuation">[</span>q<span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">lca</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> is_ancestor<span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> p
    <span class="token keyword">if</span> is_ancestor<span class="token punctuation">(</span>q<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> q
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> is_ancestor<span class="token punctuation">(</span>up<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
            p <span class="token operator">=</span> up<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">return</span> up<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">nonlocal</span> time
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>
    timein<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> time
    time <span class="token operator">+=</span> <span class="token number">1</span>
    up<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>l
    up<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> p
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
        up<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> up<span class="token punctuation">[</span>up<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">)</span>
    dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">)</span>
    timeout<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> time
    
time<span class="token punctuation">,</span>l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">20</span> <span class="token comment"># supports 2**19 nodes</span>
up<span class="token punctuation">,</span>timein<span class="token punctuation">,</span>timeout <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span>root<span class="token punctuation">)</span>
    
<span class="token keyword">print</span><span class="token punctuation">(</span>lca<span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># lowest common ancestor in O(log(n))</span>
</code></pre>
</details>
<p>Problem where you need to use optimised LCA:</p>
<ul>
<li><a href="https://leetcode.com/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/">queries in tree</a></li>
</ul>
<ul>
<li><a href="https://www.codechef.com/problems/LGSEG">longest good segement</a></li>
</ul>
<ul>
<li>semi brute force, for each index i (starting index), find largest good segment</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>N<span class="token punctuation">,</span>K<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
        seg<span class="token punctuation">,</span>curr<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span>
        <span class="token keyword">while</span> seg <span class="token operator">&#x3C;=</span> K <span class="token keyword">and</span> j<span class="token operator">&#x3C;</span>N<span class="token punctuation">:</span>
            <span class="token keyword">if</span> curr <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> S<span class="token punctuation">:</span>
                curr <span class="token operator">=</span> <span class="token number">0</span>
                seg <span class="token operator">+=</span> <span class="token number">1</span>
            curr <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> j<span class="token operator">-</span>i<span class="token operator">-</span><span class="token punctuation">(</span>seg<span class="token operator">></span>K<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>compute<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</details>
<ul>
<li>binary lifting = jumps</li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python">
<span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span>start_index<span class="token punctuation">)</span><span class="token punctuation">:</span>
    up <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>N <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    up<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> start_index
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>
            p <span class="token operator">=</span> up<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> up<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">]</span>
    <span class="token keyword">return</span> up

<span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> node<span class="token punctuation">,</span> K<span class="token punctuation">)</span><span class="token punctuation">:</span>
    last<span class="token punctuation">,</span>jump <span class="token operator">=</span> node<span class="token punctuation">,</span><span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">break</span>
        <span class="token keyword">if</span> K <span class="token operator">&#x26;</span> jump<span class="token punctuation">:</span>
            node <span class="token operator">=</span> up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span>
        jump <span class="token operator">&#x3C;&#x3C;</span><span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> last<span class="token operator">-</span>node

<span class="token keyword">def</span> <span class="token function">solve2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>N<span class="token punctuation">,</span>K<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start_index<span class="token punctuation">,</span>j<span class="token punctuation">,</span>curr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>
        curr <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">while</span> curr <span class="token operator">></span> S<span class="token punctuation">:</span>
            curr <span class="token operator">-=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
        start_index<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    
    up <span class="token operator">=</span> build<span class="token punctuation">(</span>N<span class="token punctuation">,</span>start_index<span class="token punctuation">)</span>
    res <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> call<span class="token punctuation">(</span>up<span class="token punctuation">,</span>i<span class="token punctuation">,</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> res

</code></pre>
</details>
<p><a class="color-tag" style="--tag-color: #ef4026;" href="/dendron-wiki/notes/2pzhpouodnn9fn9451isbr6">#QED</a></p>
<h2 id="lowest-common-ancestor---farach-colton-and-bender-algorithm">Lowest Common Ancestor - Farach-Colton and Bender algorithm<a aria-hidden="true" class="anchor-heading icon-link" href="#lowest-common-ancestor---farach-colton-and-bender-algorithm"></a></h2>
<h2 id="solve-rmq-by-finding-lca">Solve RMQ by finding LCA<a aria-hidden="true" class="anchor-heading icon-link" href="#solve-rmq-by-finding-lca"></a></h2>
<h2 id="lowest-common-ancestor---tarjans-off-line-algorithm">Lowest Common Ancestor - Tarjan's off-line algorithm<a aria-hidden="true" class="anchor-heading icon-link" href="#lowest-common-ancestor---tarjans-off-line-algorithm"></a></h2>
<hr>
<h1 id="flows-and-related-problems">Flows and related problems<a aria-hidden="true" class="anchor-heading icon-link" href="#flows-and-related-problems"></a></h1>
<pre><code>Maximum flow - Ford-Fulkerson and Edmonds-Karp
Maximum flow - Push-relabel algorithm
Maximum flow - Push-relabel algorithm improved
Maximum flow - Dinic's algorithm
Maximum flow - MPM algorithm
Flows with demands
Minimum-cost flow
Assignment problem
- [min XOR sum](https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/)
- hungarian algo?
</code></pre>
<p>Matchings and related problems
Bipartite Graph Check
Kuhn's Algorithm - Maximum Bipartite Matching</p>
<h1 id="miscellaneous">Miscellaneous<a aria-hidden="true" class="anchor-heading icon-link" href="#miscellaneous"></a></h1>
<h2 id="topological-sorting">Topological Sorting<a aria-hidden="true" class="anchor-heading icon-link" href="#topological-sorting"></a></h2>
<p>For DAGs only. Topo sort exists only if there are no cycles in the DAG.</p>
<ul>
<li>use dfs</li>
<li>after you have exosted vertex <code>s</code>, append it as all its descendants have been visited.</li>
<li>think of exit/finish times</li>
<li>need to reverse answer in the end</li>
<li>below version we also track if there is a cycle</li>
</ul>
<details>
<summary> <b>CODE</b> </summary>
<pre class="language-python"><code class="language-Python"><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">nonlocal</span> cycle
    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token keyword">for</span> u <span class="token keyword">in</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> u <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
            dfs<span class="token punctuation">(</span>u<span class="token punctuation">,</span>path<span class="token operator">|</span><span class="token punctuation">{</span>s<span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> u <span class="token keyword">in</span> path<span class="token punctuation">:</span>
            cycle <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">return</span>
    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment"># all topo sort needs, the rest are for cycle tracking</span>
cycle<span class="token punctuation">,</span>res<span class="token punctuation">,</span>visited <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> s <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
        dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> cycle<span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
</details>
<p><a class="color-tag" style="--tag-color: #ef4026;" href="/dendron-wiki/notes/2pzhpouodnn9fn9451isbr6">#QED</a></p>
<h2 id="edge-connectivity--vertex-connectivity">Edge connectivity / Vertex connectivity<a aria-hidden="true" class="anchor-heading icon-link" href="#edge-connectivity--vertex-connectivity"></a></h2>
<h2 id="tree-painting">Tree painting<a aria-hidden="true" class="anchor-heading icon-link" href="#tree-painting"></a></h2>
<h2 id="2-sat">2-SAT<a aria-hidden="true" class="anchor-heading icon-link" href="#2-sat"></a></h2>
<h2 id="heavy-light-decomposition">Heavy-light decomposition<a aria-hidden="true" class="anchor-heading icon-link" href="#heavy-light-decomposition"></a></h2>