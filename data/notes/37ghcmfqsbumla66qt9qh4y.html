<h1 id="system-design">System Design<a aria-hidden="true" class="anchor-heading icon-link" href="#system-design"></a></h1>
<h1 id="resources">Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#resources"></a></h1>
<ul>
<li><a href="https://github.com/mukul96/System-Design-AlexXu/blob/master/System%20Design%20Interview%20An%20Insider%E2%80%99s%20Guide%20by%20Alex%20Xu%20(z-lib.org).pdf">System Design Interview An Insiderâ€™s Guide by Alex Xu </a></li>
<li><a href="https://imaginary-basket-cbb.notion.site/System-Design-Interview-By-Alex-Xu-Book-Summary-17d97a868610804dbaf7e81fa7582caa">Notes on Alex Xu Book</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer">System Design Primer</a></li>
<li><a href="https://github.com/Jeevan-kumar-Raj/Grokking-System-Design">Grokking the System Design Interview github notes</a></li>
<li>drawing tool <a href="https://excalidraw.com/">escalidraw</a></li>
<li><a href="https://www.youtube.com/watch?v=WV2Ed1QTst8">TechLead overview</a></li>
<li><a href="https://www.systemdesignacademy.com/">Blog on System Design topics</a>, one of its articles was liked by William (IMO best competitor)</li>
</ul>
<p><em>Strategy prep</em></p>
<ul>
<li>read this notes</li>
<li>Anki notes and questions (you have an app)</li>
<li>System Design Primer github repo</li>
<li>System Design Interview insider book</li>
</ul>
<p><em>Tackle the problem by doing it just like you would at work.</em></p>
<p>A 4-step process for effective system design interview:</p>
<p><strong>1. Understand the problem and establish design scope</strong></p>
<p>Goal: Gather requirements and clarify assumptions. WRITE THEM DOWN.
Never start start designing before understanding <strong>requirements</strong>.</p>
<p>Example questions: Product question -> technical question</p>
<pre><code>DESIGN QUESTIONS
</code></pre>
<p><strong>Feature/Functional requirements</strong></p>
<ul>
<li>What are the required features for the system? -> Main <strong>functionalities</strong>?</li>
<li>Who are my clients (external, internal, quants, mobile, web, international)?</li>
<li>How are they going to use it? -> What <strong>services</strong> clients want to run? (determine API-s functions)</li>
<li>Have we built this service before, or I am building it for the first time?</li>
<li>What do we want to optimize with our design -> Determine logging metrics</li>
</ul>
<p><strong>Non-functional requirements</strong></p>
<ul>
<li>How many users are there? -> Horizontal vs Vertical Scalability</li>
<li>Whats the traffic volume, DAU? -> Single Server setup or MultiServer Setup?</li>
<li>Internal or External or Global system? -> Do we need high availability?</li>
<li>Available or Consistent data storage? -> Determine tradeoff in CAP theorem</li>
<li>How fast do we want to answer requests? -> Latency vs Consistency?</li>
<li>How many requests per second do we expect?</li>
<li>What is the scale of the system? Is it built for a startup or a big company with a large user base? -> Scalability?</li>
<li>Scale of the system such as requests per second (<strong>RPS</strong>), requests types, data written per second, data read per second)</li>
<li>Automatic scaling? The addition/deletion of servers should be automatic based on traffic?</li>
</ul>
<pre><code>DATA QUESTIONS
</code></pre>
<ul>
<li>What are the <strong>I/O</strong> of the system? <strong>Data Flow</strong></li>
<li><strong>Data Volumes</strong>(if need horizontal scaling use consistent hashing)</li>
<li>What <strong>type of data</strong> would I need to store? Just text, or images videos? Static Dynamic content?</li>
<li>What is the expected <strong>read to write ratio</strong>, read or write oriented.? (Master-Master, or Master-Slave database)</li>
<li>If we need to horizontally scale do we have <strong>evenly distributed data</strong>? Celebrity problem?</li>
<li>How long we need to keep the data?</li>
<li>If we do historical loads how much back in time should they be?</li>
<li>What's the distribution of accessing data? Is a long tail one (suitable for caching popular content).</li>
<li>Do we need to our data store to be agile? Change and process in real time?</li>
<li>On-prem or in the cloud?</li>
<li>What are my endpoints of different parts what APIs would I need?</li>
</ul>
<pre><code>Implementation questions
</code></pre>
<ul>
<li>Building from scratch? Can we use Third-Party API-s.</li>
<li>Can we leverage some of the existing cloud infrastructures provided by Amazon, Google, or Microsoft?</li>
</ul>
<p><strong>2. Propose high-level design and engage interviewer</strong></p>
<p>Goal: Propose blueprint of initial design. Ask for feedback.</p>
<p>"Does that seem like a sensible strategy?"</p>
<p>Tasks:</p>
<ul>
<li>Do back-of-the-envelope calculations to evaluate if your blueprint fits the scale constraints
Commonly asked back-of-the-envelope estimations: QPS, peak QPS, storage, cache, number of servers
QPS = queries per second. 1 day ~ 80,000 seconds</li>
<li>Draw box diagrams with key components (Clients (user) mobile/web), APIs, web servers, data stores, cache, CDN, message queue.</li>
</ul>
<p><strong>3. Design deep dive</strong>
Once you agree with your interviewer on the blueprint, go into details on each component. <em>Design the most critical components first.</em> This part is specific to the interview and interviewer.</p>
<p><strong>4. Wrap up</strong>
Interviewer asks follow up questions. Or you can do some further discussion.
Topics:</p>
<ul>
<li>Monitoring your solution (analytics to decide whether the solution is good).</li>
<li>Performance optimization - e.g do we need multi data center setup using clouod provider</li>
<li>Identify system bottlenecks and discuss potential improvements</li>
<li><strong>Recap your design</strong></li>
<li>Error cases (server failure, network loss, etc.) are interesting to talk about.</li>
<li>Operation issues are worth mentioning. How do you monitor metrics and error logs?</li>
<li>Scale the design - load balancer, horizontal scaling, caching, database sharding</li>
<li>Discuss trade-offs:</li>
</ul>
<pre><code>Performance vs scalability
Latency vs throughput
Availability vs consistency
</code></pre>
<h2 id="general-tips">General tips<a aria-hidden="true" class="anchor-heading icon-link" href="#general-tips"></a></h2>
<ul>
<li>gather requirement and write them down (don't be afraid to ask stupid questions)</li>
<li>start with simplest possible setup (single server, single database, single storage)</li>
<li>iterate, improve crucial parts (database (sharding,replication); storage(AWS S3, replicated buckets); load balancer)</li>
<li>make improvements on more important parts first (database usually goes down before server)</li>
</ul>
<h2 id="horizontal-scaling-improvements">Horizontal scaling improvements<a aria-hidden="true" class="anchor-heading icon-link" href="#horizontal-scaling-improvements"></a></h2>
<p>CCARRF</p>
<ul>
<li>loose consistency</li>
<li>loose complexity</li>
<li>win availability</li>
<li>win reliability</li>
<li>win redundancy</li>
<li>win failover (no SPOF)</li>
</ul>
<h2 id="buzz-words">Buzz words<a aria-hidden="true" class="anchor-heading icon-link" href="#buzz-words"></a></h2>
<p>horizontal, vertical scaling, availability, failover, reliability, redundancy, consistency, maintainability, load balancer, message queue, asynchronism, workers, data streaming services, database partitioning (split incoming data into different databases based on data rule e.g a-n, n-z), database replication (master-slaves, master-master), sharding, synchronization, parallel computing, SHA code, cache, CDN, Availability Zones (Data Centers), SQL = relational, NoSQL = non relational databases, celebrity problem (in data bases), reads >> writes usually (use cache), volatile memory = temporary memory, memcache (caching SQL) = <a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">@cache (Private)</a> in python, MongoDB = document database, DynamoDB = key-value store, stateless vs stateful web tier, user session data, VPS(Virtual Private Server) = your own ubunto (EC2 instance) vs shared hosts, hypervisors, sharded database (shards), normalized and de-normalized databases, high cohesion low coupling (scale independently), single point of failure SPOF, Disk slower than In-memory database slower than In-memory cache, ACID properties of a relational database, Transaction, CAP theorem, PACELC theorem (high availability=data replication -> tradeoff between consistency and latency) BLOB (binary large object), BLOB cache, TTL, weak/eventual/strong consistency, cache-aside, cache write-through, cache-write-through, cache-write-back, cache-refresh-ahead, distributed system, multi-server setup, micro-services, database transaction, begin->select-> commit/rollback</p>
<h1 id="youtube">Youtube<a aria-hidden="true" class="anchor-heading icon-link" href="#youtube"></a></h1>
<p><a href="https://www.youtube.com/watch?v=-W9F__D3oY4">Harvard Scalability lecture</a></p>
<p>When looking for host providers:</p>
<ul>
<li>FTP vs SFTP (secured file transfer protocol)</li>
<li>VPS (virtual private server) vs shared hosts(many users use same server)</li>
<li>VPS are your EC2 instances in AWS (your own ubunto) safe from other users but still susceptible to the provider</li>
<li>VPS uses hypervisors. A hypervisor, also known as a virtual machine monitor or VMM, is software that creates and runs virtual machines (VMs).</li>
</ul>
<p>Load balancer strategies to balance:</p>
<ul>
<li>based on work load, least busy servers take the work</li>
<li>dedicated servers for specific jobs (html server, Python server etc.)</li>
<li>job i is taken by server i % N (problem might not have uniformly distributed workload)</li>
</ul>
<p>Load balancer problem? Single Point of Failure.</p>
<ul>
<li>buy 2 load balancers (pretty expensive 100k)</li>
</ul>
<p>RAID technology is a virtualization of data memory - data many disks put into "one" and keep copy/backups to be safe.</p>
<p>Stateless architecture to have easier horizontal scaling on the web tier. Keep session data in NoSQL/SQL database shared by all servers (SPOF), better replicate it.</p>
<p>MySQL caches queries, the same query running more than once is cached.
memcache is like <a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">@cache (Private)</a> in Python</p>
<p>Database replication - Master-Master, Master Slaves</p>
<p>Database partitioning - partition incoming data using some rule (a-n, n-z) and split into different databases</p>
<p><a href="https://www.youtube.com/watch?v=REB_eGHK_P4">Tech lead</a></p>
<p>Load balancing help to distribute traffic to many different servers. Helps scalability, latency, throughput.</p>
<p>NGINX is a load balancing software service.
Can do DNS load balancing. Make the DNS returns you different ip addresses for same domain distributing to different servers.</p>
<p>Throughput is a measure of how many units of information a system can process in a given amount of time.</p>
<p>Caching - e.b often you'd hitting the database (reads) you need to setup cache.
Cache services Memcached, Redis, Cassandra</p>
<p>CDN-s store static data, global network which caches your content.</p>
<p>In interview might be asked to design a database schema:</p>
<ul>
<li>what are the primary keys</li>
<li>what are your indecies</li>
</ul>
<p>Indecies in a database make it fast - no need to do linear search in WHERE clause, indecing gives you random access.
Indexing your table improves the joins - nee to index the column on which you join.</p>
<p>Database optimizations:</p>
<ul>
<li>replication (master slaves) </li>
<li>indexing</li>
</ul>
<p>Scaling stuff:</p>
<ul>
<li>Webservers - use load balancers to do horizontal scaling</li>
<li>Image server - CDN, cache</li>
<li>Database server - cache, replication (solves reads)</li>
<li>Database server writes - Sharding</li>
</ul>
<p>Sharding your database (database partitioning) - horizontal (split rows) and vertical (split different columns) sharding
Each shard goes to different server.</p>
<p>You don't want to scale too early and put optimization in the begining.</p>
<p><a href="https://www.youtube.com/watch?v=q0KGYwNbf-0">Clement System Design interview example</a></p>
<h1 id="databases">Databases<a aria-hidden="true" class="anchor-heading icon-link" href="#databases"></a></h1>
<h2 id="differences-between-sql-and-nosql">Differences between SQL and NoSQL<a aria-hidden="true" class="anchor-heading icon-link" href="#differences-between-sql-and-nosql"></a></h2>
<h3 id="storage">Storage<a aria-hidden="true" class="anchor-heading icon-link" href="#storage"></a></h3>
<ul>
<li>SQL: store data in tables.</li>
<li>NoSQL: have different data storage models.</li>
</ul>
<h3 id="schema">Schema<a aria-hidden="true" class="anchor-heading icon-link" href="#schema"></a></h3>
<ul>
<li>SQL
<ul>
<li>Each record conforms to a fixed schema.</li>
<li>Schema can be altered, but it requires modifying the whole database.</li>
</ul>
</li>
<li>NoSQL:
<ul>
<li>Schemas are dynamic.</li>
</ul>
</li>
</ul>
<h3 id="querying">Querying<a aria-hidden="true" class="anchor-heading icon-link" href="#querying"></a></h3>
<ul>
<li>SQL
<ul>
<li>Use SQL (structured query language) for defining and manipulating the data.</li>
</ul>
</li>
<li>NoSQL
<ul>
<li>Queries are focused on a collection of documents.</li>
<li>UnQL (unstructured query language).</li>
<li>Different databases have different syntax.</li>
</ul>
</li>
</ul>
<h3 id="scalability">Scalability<a aria-hidden="true" class="anchor-heading icon-link" href="#scalability"></a></h3>
<ul>
<li>SQL
<ul>
<li>Vertically scalable (by increasing the horsepower: memory, CPU, etc) and expensive.</li>
<li>Horizontally scalable (across multiple servers); but it can be challenging and time-consuming.</li>
</ul>
</li>
<li>NoSQL
<ul>
<li>Horizontablly scalable (by adding more servers) and cheap.</li>
</ul>
</li>
</ul>
<h3 id="acid">ACID<a aria-hidden="true" class="anchor-heading icon-link" href="#acid"></a></h3>
<ul>
<li>Atomicity, consistency, isolation, durability</li>
<li>SQL
<ul>
<li>ACID compliant</li>
<li>Data reliability</li>
<li>Gurantee of transactions</li>
</ul>
</li>
<li>NoSQL
<ul>
<li>Most sacrifice ACID compliance for performance and scalability.</li>
</ul>
</li>
</ul>
<h2 id="which-one-to-use">Which one to use?<a aria-hidden="true" class="anchor-heading icon-link" href="#which-one-to-use"></a></h2>
<h3 id="sql">SQL<a aria-hidden="true" class="anchor-heading icon-link" href="#sql"></a></h3>
<ul>
<li>Ensure ACID compliance.
<ul>
<li>Reduce anomalies.</li>
<li>Protect database integrity.</li>
</ul>
</li>
<li>Data is structured and unchanging.</li>
</ul>
<h3 id="nosql">NoSQL<a aria-hidden="true" class="anchor-heading icon-link" href="#nosql"></a></h3>
<ul>
<li>Data has little or no structure.</li>
<li>Make the most of cloud computing and storage.
<ul>
<li>Cloud-based storage requires data to be easily spread across multiple servers to scale up.</li>
</ul>
</li>
<li>Rapid development.
<ul>
<li>Frequent updates to the data structure.</li>
</ul>
</li>
</ul>
<p><strong>Reasons for SQL:</strong></p>
<ul>
<li>Structured data</li>
<li>Strict schema</li>
<li>Relational data</li>
<li>Need for complex joins</li>
<li>Transactions</li>
<li>Clear patterns for scaling</li>
<li>More established: developers, community, code, tools, etc</li>
<li>Lookups by index are very fast</li>
</ul>
<p><strong>Reasons for NoSQL:</strong></p>
<ul>
<li>Semi-structured data</li>
<li>Dynamic or flexible schema</li>
<li>Non-relational data</li>
<li>No need for complex joins</li>
<li>Store many TB (or PB) of data</li>
<li>Very data intensive workload</li>
<li>Very high throughput for IOPS</li>
</ul>
<h2 id="common-types-of-nosql">Common types of NoSQL<a aria-hidden="true" class="anchor-heading icon-link" href="#common-types-of-nosql"></a></h2>
<h3 id="key-value-stores">Key-value stores<a aria-hidden="true" class="anchor-heading icon-link" href="#key-value-stores"></a></h3>
<ul>
<li>Array of key-value pairs. The "key" is an attribute name.</li>
<li>Redis, Vodemort, Dynamo.</li>
</ul>
<h3 id="document-databases">Document databases<a aria-hidden="true" class="anchor-heading icon-link" href="#document-databases"></a></h3>
<ul>
<li>KeyValue, but values are documents.</li>
<li>Documents are grouped in collections.</li>
<li>Each document can have an entirely different structure.</li>
<li>CouchDB, MongoDB , Dynamo</li>
</ul>
<h3 id="wide-column--columnar-databases">Wide-column / columnar databases<a aria-hidden="true" class="anchor-heading icon-link" href="#wide-column--columnar-databases"></a></h3>
<ul>
<li>Column families - containers for rows.</li>
<li>No need to know all the columns up front.</li>
<li>Each row can have different number of columns.</li>
<li>Cassandra, HBase.</li>
</ul>
<h3 id="graph-database">Graph database<a aria-hidden="true" class="anchor-heading icon-link" href="#graph-database"></a></h3>
<ul>
<li>Data is stored in graph structures
<ul>
<li>Nodes: entities</li>
<li>Properties: information about the entities</li>
<li>Lines: connections between the entities</li>
</ul>
</li>
<li>Neo4J, InfiniteGraph</li>
</ul>
<h1 id="system-design-interview---an-insider-guide">System Design Interview - An Insider Guide<a aria-hidden="true" class="anchor-heading icon-link" href="#system-design-interview---an-insider-guide"></a></h1>
<h2 id="chapter-1---scale-from-zero-to-million-users">Chapter 1 - Scale from zero to million users<a aria-hidden="true" class="anchor-heading icon-link" href="#chapter-1---scale-from-zero-to-million-users"></a></h2>
<p>This chapter discusses the process of scaling from a single web server to an architecture with:
User, DNS, CDN, Load Balancer, Web tier (Stateless servers), Data Tier (Sharded Databases + Replication), Cache,
NoSQL database to keep user session data (stateless servers), message queue, logging and metric tools, Data Centers for
international coverage.</p>
<p>â€¢ Keep web tier stateless \
â€¢ Build redundancy at every tier \
â€¢ Cache data as much as you can \
â€¢ Support multiple data centers \
â€¢ Host static assets in CDN \
â€¢ Scale your data tier by sharding \
â€¢ Split tiers into individual services \
â€¢ Monitor your system and use automation tools</p>
<p><img src="/dendron-wiki/assets/images/web_traffic.png" alt="web_traffic.png"></p>
<p>System Design : <a href="https://bit.ly/41PTaAp">https://bit.ly/41PTaAp</a><br>
Winning System Design Case Studies: <a href="https://tinyurl.com/yfvyrjn7">https://tinyurl.com/yfvyrjn7</a><br>
Github : <a href="https://shorturl.at/hlow0">https://shorturl.at/hlow0</a><br>
ML System Design Series : <a href="https://rb.gy/dd8dfe">https://rb.gy/dd8dfe</a><br>
Design Google Drive : <a href="https://bit.ly/3uXdQZ7">https://bit.ly/3uXdQZ7</a><br>
Design Messenger App : <a href="https://bit.ly/3DoAAXi">https://bit.ly/3DoAAXi</a><br>
Design Instagram : <a href="https://bit.ly/3BFeHlh">https://bit.ly/3BFeHlh</a><br>
Design Twitter : <a href="https://bit.ly/3qIG9Ih">https://bit.ly/3qIG9Ih</a><br>
Design Robinhood : <a href="https://bit.ly/3BFeHlh">https://bit.ly/3BFeHlh</a><br>
Design Swiggy: <a href="https://bit.ly/3BFeHlh">https://bit.ly/3BFeHlh</a><br>
Design CashApp : <a href="https://bit.ly/3BFeHlh">https://bit.ly/3BFeHlh</a><br>
Design Kayak: <a href="https://bit.ly/3DoAAXi">https://bit.ly/3DoAAXi</a><br>
Design Paytm : <a href="https://bit.ly/3qIG9Ih">https://bit.ly/3qIG9Ih</a><br>
Design ESPN Streaming : <a href="https://bit.ly/3qIG9Ih">https://bit.ly/3qIG9Ih</a><br>
Design Agoda : <a href="https://bit.ly/3xP078x">https://bit.ly/3xP078x</a><br>
Design Razorpay : <a href="https://bit.ly/3xP078x">https://bit.ly/3xP078x</a><br>
Design Apple Music : <a href="https://bit.ly/3xP078x">https://bit.ly/3xP078x</a><br>
Design CricHD: <a href="https://bit.ly/3xP078x">https://bit.ly/3xP078x</a><br>
Design Alibaba: <a href="https://bit.ly/3xP078x">https://bit.ly/3xP078x</a><br>
Design Substack: <a href="https://bit.ly/3xP078x">https://bit.ly/3xP078x</a><br>
Design TrueCaller: <a href="https://shorturl.at/pzABN">https://shorturl.at/pzABN</a><br>
Design Stock exchange Design System: <a href="https://shorturl.at/svCK1">https://shorturl.at/svCK1</a><br>
Design Distributed Cache : <a href="https://shorturl.at/fjBV6">https://shorturl.at/fjBV6</a><br>
Design Twilio : <a href="https://shorturl.at/uDJP7">https://shorturl.at/uDJP7</a><br>
Design Google Docs : <a href="https://tinyurl.com/mr4d9v83">https://tinyurl.com/mr4d9v83</a><br>
Design Doordash : <a href="https://tinyurl.com/27nh5s7s">https://tinyurl.com/27nh5s7s</a><br>
Design MS Docs : <a href="https://tinyurl.com/9fpa8jpc">https://tinyurl.com/9fpa8jpc</a><br>
Design Zomato : <a href="https://tinyurl.com/566t34ph">https://tinyurl.com/566t34ph</a><br>
Design Linkedin : <a href="https://bit.ly/3OjXy7c">https://bit.ly/3OjXy7c</a><br>
Design Google Maps : <a href="https://bit.ly/3BDdTwn">https://bit.ly/3BDdTwn</a><br>
Design Telegram : <a href="https://bit.ly/42N5LW2">https://bit.ly/42N5LW2</a><br>
Design Snapchat : <a href="https://bit.ly/3pRP3pW">https://bit.ly/3pRP3pW</a><br>
Design One Drive : <a href="https://bit.ly/438bAwZ">https://bit.ly/438bAwZ</a><br>
Design Quora : <a href="https://bit.ly/3FeD9dL">https://bit.ly/3FeD9dL</a><br>
Design Tinder : <a href="https://bit.ly/3Mcyj3X">https://bit.ly/3Mcyj3X</a><br>
Design TikTok : <a href="https://bit.ly/3UUlKxP">https://bit.ly/3UUlKxP</a><br>
Design Netflix : <a href="https://bit.ly/3GrAUG1">https://bit.ly/3GrAUG1</a><br>
Design Uber : <a href="https://bit.ly/3fyvnlT">https://bit.ly/3fyvnlT</a><br>
Design Youtube : <a href="https://bit.ly/3dFyvvy">https://bit.ly/3dFyvvy</a><br>
Design Reddit : <a href="https://bit.ly/3OgGJrL">https://bit.ly/3OgGJrL</a><br>
Design Facebookâ€™s Newsfeed : <a href="https://bit.ly/3RldaW7">https://bit.ly/3RldaW7</a><br>
Design Amazon Prime Video : <a href="https://bit.ly/3hVpWP4">https://bit.ly/3hVpWP4</a><br>
Design Dropbox : <a href="https://bit.ly/3SnhncU">https://bit.ly/3SnhncU</a><br>
Design Yelp: <a href="https://bit.ly/3E7IgO5">https://bit.ly/3E7IgO5</a><br>
Design Whatspp : <a href="https://bit.ly/3M2GOhP">https://bit.ly/3M2GOhP</a>  </p>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/dendron-wiki/notes/82lxbmwgtrgestyejv1wg2j">All interview stages</a></li>
</ul>